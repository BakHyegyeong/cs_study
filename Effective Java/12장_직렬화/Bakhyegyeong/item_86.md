# 아이템 86 : Serializable을 구현할지는 신중히 결정하라

어떤 클래스의 인스턴스를 직렬화할 수 있게 하려면 클래스 선언에 `implements Serializable`만 덧붙이면 되지만 몇 가지 문제점이 존재한다.

# 직렬화의 문제점

## 1. 릴리즈한 뒤 수정하기 어렵다.

클래스가 Serializable을 구현하면 직렬화된 바이트 스트림 인코딩도 **하나의 공개 API**가 된다. 

- 기본 직렬화 형태를 사용하면 private와 package-private 인스턴스 필드마저 API로 공개해 캡슐화와 깨진다.
- 적용 당시의 클래스 내부 구현 방식에 묶이게 된다.
- 뒤늦게 클래스 내부 구현을 손보면 직렬화 형태가 달라지므로 버전 호환성이 깨진다.

그렇기에 직렬화 클래스를 만들 때는 길게 지원할 수 있는 것뿐만 아니라 고품질의 직렬화 형태도 주의해서 함께 설계해야 한다.

### **직렬화가 클래스 개선을 방해하는 예**

모든 직렬화된 클래스는 **고유 식별 번호를 부여**받는다.

→ 이 값을 생성하는 데는 클래스 이름, 구현한 인터페이스들, 컴파일러가 자동으로 생성하는 것을 포함한 대부분의 클래스 멤버들이 고려된다.

→ 나중에 편의 메서드를 추가하는 식으로 **이들 중 하나라도 수정한다면 직렬 버전 UID 값도 변하며 호환성이 깨져버리게** 된다.

## 2. **버그와 보안 구멍이 생길 위험이 높아진다.**

객체는 생성자를 사용해 만드는 게 기본인데, 직렬화는 이 기본 메커니즘을 우회하는 객체 생성 기법이다.

→ 하지만 **역직렬화는 일반 생성자의 문제가 그대로 적용되는 숨은 생성자**이다.

→ 생성자에서 구축한 불변식을 모두 보장해야 하고 생성 도중 공격자가 객체 내부를 들여다 볼 수 없도록 해야 한다는 규칙을 떠올리기 어렵다.

→ 그렇기에 역직렬화를 사용하면 **불변식 깨짐과 허가되지 않은 접근에 쉽게 노출**된다.

## 3. **해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다.**

- 구버전과 신버전의 양방향 직렬화/역직렬화가 모두 성공해야 한다.
- 원래 객체를 충실히 복제해내는지 또한 확인해야 한다.

## **Serializable** 주의사항

1. Serializable 구현 여부를 가볍게 결정하지 말아야 한다.
    - 객체를 전송하거나 저장할 때 자바 직렬화를 이용하는 프레임워크용으로 만든 클래스
    - Serializable을 반드시 구현해야 하는 다른 클래스의 컴포넌트로 쓰일 클래스
    - BigInteger와 Instant 같은 '값' 클래스와 컬렉션 클래스들
    
    → 위의 경우가 아니라면 Serializable 구현에 대해서 신중해야 한다.
    
2. 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안 되며, 인터페이스도 대부분 Serializable을 확장해서는 안 된다.
3. 내부 클래스는 직렬화를 구현하지 말아야 한다.
    
    → static 내부 클래스는 바깥 클래스의 필드를 가져오기 때문에 원치 않은 직렬화가 이루어질 수 있다.
    

### **Serializable을 구현하면서 확장이 가능한 클래스를 만들어야만 할 때**

Serializable을 구현한 클래스만 지원하는 Framwork를 사용하는 상황인 경우에는 아래의 방법을 따라야 한다.

- finalize 메서드를 재정의하지 못하게 막아야 한다.
    
    → finalize 메서드를 재정의하여 final로 선언한다.
    
- 인스턴스 필드 중 기본값(0, false, null)으로 초기화되면 위배되는 불변식은 **readObjectNoData 메서드**를 반드시 추가한다.
    
    ```java
    private void readObjectNoData() throws InvalidObjectException {
        throw new InvalidObjectException("스트림 데이터가 필요합니다.");
    }
    ```
    

### **Serializable를 구현하지 않는다면**

상속용 클래스인데 직렬화를 지원하지 않으면 하위 클래스가 직렬화를 지원하려 할 때 부담이 늘어날 수 있다.

→ 그럴 경우 아래의 방법을 통해서 해결할 수 있다.

- 상위 클래스에서 **매개변수 없는 생성자**를 제공해야 한다.
- 혹은 하위 클래스에서 **직렬화 프록시 패턴**(Item 90)을 사용해야 한다.

## 핵심 정리

- Serializable은 구현한다고 선언하기는 아주 쉽지만, 그것은 눈속임일 뿐이다.
- 한 클래스의 여러 버전이 상호작용할 일이 없고 서버가 신뢰할 수 없는 데이터에 노출될 가능성이 없는 등, 보호된 환경에서만 쓰일 클래스가 아니라면 Serializable 구현은 아주 신중히 이뤄져야 한다.
- 상속할 수 있는 클래스라면 더욱 주의해야한다.