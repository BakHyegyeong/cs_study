# 아이템 70 : 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

# 예외의 종류

자바는 **문제 상황을 알리는 타입**(throwable)으로 다음의 세가지를 제공한다.

- 검사 예외 (Checked Exception)
- 런타임 예외 (Runtime Exception)
    - 비검사 예외 (Unchecked Exception)
- 에러 (Error)

![](https://user-images.githubusercontent.com/59357153/144165617-d389bb7c-0a11-47dc-b24a-5aab326a5982.png)

## 검사 예외 (Checked Exception)

호출자는 반드시 그 예외를 `catch` 로 잡아 처리하거나 `throws` 를 통해 더 바깥으로 전파하도록 **강제해야 한다.**

- 컴파일 단계에서 확인이 가능하다.
- `IOException` 등

## 런타임 예외

**프로그래밍 오류를 나타낼 때** 사용한다.

- 전제조건을 만족하지 못했을 때
    
    → 클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못했을때 발생한다.
    
- 복구가 가능하지 않으므로 예외 검사를 강제하지 않는다.

### 비검사 예외 (Unchecked Exception)

검사 예외와 달리 프로그램에서 잡을 필요가 없거나, 혹은 통상적으로 **잡지 말아야 한다.** 

- 런타임 단계에서 확인이 가능하다.
- 비검사 `throwable` 은 모두 `RuntimeException` 의 하위 클래스어야한다.
- `IllegalArgumentException`, `NullPointerException` 등

## 에러

**JVM이 자원의 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황**을 나타낼 때 사용한다.

- Java 언어 명세에 된 것은 아니지만 업계에 널리 퍼진 규약으로 **`Error` 클래스를 상속해 하위 클래스를 만드는 일은 자제**해야 한다.
- `Error`는 상속 뿐만 아니라 `throw` 문으로 직접 던져서도 안된다.

## 예외 메서드

예외도 하나의 객체이므로, 어떠한 메서드라도 정의할 수 있다.

- **예외를 일으킨 상황에 대한 정보**를 코드 형태로 전달하는데 사용된다.
    
    → 만약 메서드를 정의하지 않는다면 프로그래머들은 오류 메시지를 파싱해 직접 정보를 빼내야 하므로 정의하는 것이 좋다.
    
- **검사 예외는 호출자가 예외 상황에서 벗어나 복구할 수 있도록 필요한 정보를 알려주는 메서드**를 함께 제공해야 한다.

## 핵심 정리

- 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자.
- 검사 예외도 아니고 런타임 예외도 아닌 `throwable` 은 정의하지도 말자.
- 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.