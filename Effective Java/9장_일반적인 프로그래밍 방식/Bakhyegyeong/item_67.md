# 아이템 67 : 최적화는 신중히 하라

# 최적화

최적화는 섣불리 진행하면 좋은 결과보다 **해로운 결과로** 이어지기 쉽다.

- 견고한 구조를 해치는 최적화의 경우 진행하지 않는 것이 좋다.
- 빠른 프로그램보다는 좋은 프로그램을 작성해야 한다.

### 좋은 프로그램

- 좋은 프로그램은 **개별 구성요소의 내부를 독립적**으로 설계 가능한 것
- **시스템의 나머지에 변화를 주지 않고도** 내가 원하는 부분에 변화를 줄 수 있다.

## 좋은 설계

### 성능을 제한하는 설계를 피해야 한다.

- **설계적인 요소는 완성 후 변경하기가 가장 어렵다.**
    - 설계적인 요소 : API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등
- 변경이 불가능할 수도 있고 시스템 성능도 크게 제한될 수 있기 때문에 **설계 단계에서 성능을 염두**해야 한다.

### **API 설계 시 성능에 주는 영향을 고려하라**

1. `public` 타입을 가변으로 만들어 내부 데이터를 변경할 수 있게 만드는 것은, 불필요한 방어적 복사를 유발한다.
    
    ```java
    public abstract class Component implements ImageObserver, MenuContainer,
                                               Serializable
    {
        public Dimension getSize() {
            return size();
        }
    
        @Deprecated
        public Dimension size() {
            return new Dimension(width, height); // 방어적 복사 수행 
        }
    }
    ```
    
2. 컴포지션으로 해결할 수 있음에도 상속 방식으로 설계한 `public` 클래스는 상위 클래스에 영원히 종속되며 그 성능 제약까지도 물려받게 된다.
    
    
    ![](https://cdn.jsdelivr.net/gh/n00nietzsche/posting_cdn@main/images/instrumentSetUML_1687856069407.png)
    
3. 인터페이스가 있는데 클래스를 구현 타입을 사용하는 것은 **특정 구현체에 종속**되게 하여, 나중에 더 빠른 구현체가 나오더라도 이용하지 못하게 된다.
    
    → 아이템 64
    

### 성능 측정

jmh 같은 **프로파일링 도구**를 이용해 성능을 개선할만한 부분을 찾을 수 있다.

→ 먼저 효율적인 구조의 프로그램을 완성한 후 최적화를 고려해야 한다.

- 알고리즘 확인 : 개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 이용해 확인할 수 있다.
- 코드 확인 : 보통 10%의 코드에서 90%의 성능을 사용한다.

## 핵심 정리

- 좋은 프로그램을 작성하다 보면 성능은 따라오므로 빠른 프로그램을 작성하려 안달하지 않아도 된다.
- 특히 API, 네트워크 프로토콜, 영구 저장용 데이터 포맷을 설계할 때는 성능을 염두해 두어야 한다.
- 시스템 구현을 다했다면 성능을 측정해보고 충분히 빠르지 않다면 프로파일러를 사용해 문제의 원인이 되는 지점을 찾아 최적화를 수행하자.
- 만족할 때까지 반복하고, 모든 변경 후에는 성능을 측정하라.