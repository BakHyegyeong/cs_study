# 아이템 64 : 객체는 인터페이스를 사용해 참조하라

객체의 실제 클래스를 사용할 상황은, 오직 **생성자로 생성할 때 뿐**이다.

→ **적합한 인터페이스만 있다면 매개변수 뿐 아니라 반환값, 변수, 필드 전부 인터페이스 타입으로 선언해야 한다.**

## 인터페이스 사용의 장점

- 저수준 코드가 변경되어도 프로덕션 코드는 변경되지 않는다.
- 원하는 구현체를 조립할 수 있다.

→ 인터페이스를 타입으로 사용하는 프로그램은 훨씬 **유연해진다.**

**예시** 

```java
// 인터페이스를 타입으로 사용
Set<Son> sonSet = new LinkedHashSet<>();

// 클래스를 타입으로 사용
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```

나중에 구현 클래스를 교체하고자 할 때 **새 클래스의 생성자를 호출**하기만 하면 된다.

```java
Set<Son> sonSet = new HashSet<>(); 
```

## **적합한 인터페이스가 없는 경우**

### 값 클래스

`String`, `BigInteger` 와 같은 값 클래스들은 적합한 인터페이스가 없다.

→ 이런 값 클래스는 매개변수, 변수, 필드, 반환 타입으로 사용해도 괜찮다.

```java
// final로 확장을 막아두었다.
public final class String
	implements java.io.Serializable, Comparable<String>, CharSequence {

```

### 클래스 기반 작성된 프레임워크

클래스 기반으로 작성된 프레임워크가 제공하는 객체들은, 적합한 인터페이스가 없다.

→ `OutputStream` 등 `java.io` 패키지의 여러 클래스가 이 부류에 속한다.

### **인터페이스에 없는 특별한 메서드를 제공하는 클래스**

원래 클래스가 인터페이스의 일반 규약 의외의 **특별한 기능을 제공**하거나 **주변 코드가 이 기능에 기대어 동작**할 경우

→ `PriorityQueue` 클래스는 `Queue` 인터페이스에 없는 `comparator`메서드를 제공한다.

## 핵심 정리

적합한 **인터페이스가 있다면 타입으로 사용**하고, 적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 **덜 구체적인(상위의) 클래스 타입으로 사용**하자.