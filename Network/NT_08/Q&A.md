## Q1. CORS 에러가 발생하는 이유는?
- SOP(Same Origin Policy) 때문에 다른 출처의 자원을 쓸 수 없어서 발생하는 에러
- 이전에는 프론트엔드와 백엔드를 구분하지 않고 같이 쓰는 방식을 채택했지만 웹 기술이 발전하면서 다른 출처로 요청을 보내는 경우가 많아져서 CORS가 등장했다.

## Q2. https://example.com과 https://example.com:443은 같은 출처인가요?
- 포트가 생략된 형태이므로 동일한 출처로 간주한다.

## Q3. SOP의 보안적 한계
- SOP는 브라우저 측에서 서버의 응답을 못 읽게 하는 것일 뿐 악의적인 요청을 보내는 것까지는 막지 못한다.

## Q4. CORS 동작 방식
1. 클라이언트에서 HTTP 요청을 보낸다. 이때 Origin 헤더에 요청을 보낸 출처를 담아 보낸다.
2. 서버에서는 응답 헤더에 `Access-Control-Allow-Origin`을 담아 응답을 보낸다.
3. 브라우저는 Origin 헤더의 출처와 응답의 `Access-Control-Allow-Origin`을 비교한다.
    - 같다면 해당 요청을 안전하다고 간주하고 응답을 가져온다.
    - 다르다면 브라우저가 해당 응답을 임의로 파기하고 자바스크립트로 응답의 내용을 전달하지 않는다.

## Q5. CORS의 요청 방식 3가지
- 단순 요청
- 예비 요청
- 인증정보를 포함한 요청

## Q6. CORS의 동작 중에서 예비 요청 방식이 있는데 이 방식은 어떤 동작 과정으로 이루어지는지
- 실제 요청을 보내기 전에 예비 요청을 보내서 해당 리소스에 접근이 가능한지 먼저 확인하는 방식

## Q7. 단순 요청이란? 예비 요청이 필요한 이유.
- 단순 요청은 CORS 요청 후에 서버로부터 응답을 바로 받아서, 브라우저가 CORS 정책 위반 여부를 검사하는 방식이다.
- 서버에 영향을 줄 수 있는 요청을 보낼 때, 만일 PUT 요청이 실행되고서 브라우저가 CORS 정책 위반을 검사하면 문제가 발생할 수 있기 때문에 예비 요청이 필요하다.

## Q8. 인증정보를 포함한 요청에서 브라우저는 어떤 옵션을 설정하는지
- 브라우저: fetch의 credentials 옵션 (Axios의 withCredentials 옵션)
- 서버: Access-Control-Allow-Credentials 의 값을 true로 설정
