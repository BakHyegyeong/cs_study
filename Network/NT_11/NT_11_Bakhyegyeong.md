# DNS

도메인 이름 시스템을 의미하며 **도메인 이름과 IP주소를 서로 변환**하는 역할

→ 사용자의 요청을 DNS Query라고 한다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F0aVTa%2Fbtrc3qfZSwE%2F0TG6odWsSmaMoLNi9UQ3E0%2Fimg.png)

## 동작 과정

1. **브라우저는 입력된 url의 IP주소를 찾기 위해 DNS 캐시를 탐색한다.**
    - DNS 서버에 요청하기 전에 캐싱된 DNS 기록을 먼저 확인하며, 해당 도메인 이름에 대응하는 IP 주소가 있으면 DNS 서버에 요청하지 않고 **캐싱된 IP 주소를 반환**한다.
    - 만약 캐싱된 DNS 기록에 없다면 DNS 서버에 요청을 보낸다.
2. **DNS  서버에서 해당 도메인 이름에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.**
    - Internet service provider (ISP)를 통해 사용자와 가장 가까운 DNS 서버에 요청을 보내며 이 DNS 서버에서는 DNS query를 통해 DNS 서버들을 탐색하며 원하는 IP 주소를 찾는다.
    - 이후 IP주소와 함께 사용자가 입력한 URL 정보를 함께 전달한다.

## **DNS Round Robin**

**DNS 서버 구성 방식 중 하나**로 별도의 소프트웨어 혹은 하드웨어 로드밸런싱 장비를 사용하지 않고, **DNS만을 이용하여** 도메인 정보를 조회하는 시점에서 **트래픽을 분산하는 기법**

![](https://mblogthumb-phinf.pstatic.net/MjAyMDAzMDRfNjAg/MDAxNTgzMjUxNzA0MTAx.f3KPOAtnK5rLTliX8YtyWj2daaBQ_Sfd-6ha9B6c_rog.EvnR_s4c1ZcJpXE1eqQVdFihKl4APbKDV7vzKNBk0Rgg.PNG.sehyunfa/image.png?type=w800)

- 웹 서비스를 담당할 **여러 대의 웹 서버는 도메인 이름은 같지만 각각 공인 IP주소를 가지고 있다.**
- 사용자가 도메인 주소를 브라우저에 입력하면 **여러 대의 서버 IP리스트 중에서 하나 혹은 여러개를 선택**하여 사용자에게 알려준다.
- 쿼리될 때마다 **최근에 응답한 IP 주소를 대기열의 뒤쪽으로** 보내며 순환 작동한다.

결과적으로 웹 사이트에 접속하는 다수의 사용자가 **실제로는 복수의 웹 서버에 나뉘어 접속하게 되면서** 자연스럽게 서버의 부하가 분산된다.

### 단점

1. **서버의 수 만큼 공인 IP 주소가 필요하다.**
    - 부하 분산을 위해 서버의 대수를 늘리기 위해서는 그만큼의 공인 IP 가 필요하다.

2. **균등하게 분산되지 않는다.**
    - DNS 캐싱과 클라이언트 쪽 캐싱으로 항상 균등하게 분산되지 않는다.
        - DNS 캐싱 : 더 빠른 조회를 위해 DNS 레코드를 캐시
        - 클라이언트 쪽 캐싱 : HTML 파일, JavaScript, 이미지를 캐시
    - 캐싱된 DNS 기록을 먼저 확인해 캐싱된 IP 주소를 반환하기 때문에 특정 IP에 많은 양의 트래픽이 몰릴 수 있다.
        
        
3. **서버가 다운되더라도 확인이 불가능하다.**
    - 서버 중 하나가 다운되더라도 DNS 서버는 해당 서버의 IP를 라운드 로빈 순환으로 유지한다.
        
        → 6개의 서버가 있고 1개가 오프라인 상태가 되면 사용자 6명 중 1명에 대한 서비스가 거부된다.
        
    - 서버 부하, 트랜잭션 시간, 지리적 거리, 기존 부하 분산 등의 요소를 고려하지 않는다.
        
        → Health check기능을 제공하지 않는다.
        

### 해결 방법

- 가중치 편성 방식 (Weighted round robin) : 각각의 웹 서버에 가중치를 설정해 분산 비율을 변경한다.
- Least connection 방식 : 접속 클라이언트 수가 가장 적은 서버를 선택하도록 하는 방식
    
    → 로드 밸런서에서 각 서버의 커넥션 수를 알아야 하므로, DNS 라운드 로빈만으로는 구현할 수 없다.
    
- Health check 기능이 포함된 AWS Route53 같은 서비스로 대체한다.

 

# **프록시 서버**

클라이언트에서 서버로 접속을 할 때 직접적으로 접속하지 않고 **중간에 대신 전달해주는** 컴퓨터 시스템이나 응용프로그램

→ 클라이언트와 서버 사이의 중재자 역할

![](https://surfshark.com/wp-content/uploads/2022/11/Proxy_server_2.svg)

## 필요한 이유

1. 보안
    - 기본적인 수준에서 IP, 장치의 온라인 주소를 가려 보안을 강화할 수 있다.
    - 클라이언트의 요청을 필터링 할 수 있다. ex) Nginx의 GeoIP
2. 캐시
    - 이전에 했던 요청들을 프록시 서버에 저장(캐시) 해두어 **다음 번에 재요청을 보낼 때 서버를 거치지 않고 데이터를 주고 받아** 속도가 빠르다.
    - 웹 프록시는 웹 서버로부터 **웹 페이지를 캐시로 저장**하는 데 흔히 쓰이며 캐싱을 통해 콘텐츠를 빠르게 가져올 수 있다.
    - 5명의 사용자가 동일한 웹 페이지를 방문하는 경우 서버는 해당 웹 페이지를 한 번 핑한 다음 **5명의 사용자에게 정보를 분배**해 네트워크 부하를 줄일 수 있다.
3. 우회
    - IP를 통해 접속을 감지하는 사이트를 프록시 서버를 통해 우회할 수 있다.

## 프록시 서버 종류

### Forward Proxy

클라이언트에서 요청을 할 때 직접 요청하는 것이 아닌 프록시 서버를 거치는 방식

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJXHrF%2FbtrzfA730Gb%2FKVanJREH83e34lIYZflklk%2Fimg.jpg)

### **Reverse Proxy**

**서버에서 클라이언트에게 직접 데이터를 전달하지 않고** 프록시 서버를 거치는 방식

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FTBHNV%2FbtrzaVSYgoo%2F0mPvscFwhGHQAc8ukeIVjk%2Fimg.jpg)

### 기타

- **웹** **프록시** **서버**: 로드 밸런서 역할을 하여 들어오는 요청을 여러 서버에 분산시켜 서비스를 유지
- **익명** **프록시** : 원래 IP 주소를 숨기고 새 IP 주소를 제공
    
    → 프록시가 사용 중이라는 사실은 숨기지 않는다.
    

## 프록시 프로토콜

- SSL : 전송 중 데이터를 보호하는 데 사용
    
    →  웹 페이지와 웹 페이지를 드나드는 데이터 트래픽을 모두 암호화
    
- FTP : 파일 전송 프로토콜
- HTTP : 하이퍼텍스트 전송 프로토콜
    
    → 웹 페이지와 파일을 캐시하여 자주 방문하는 사이트에서 더 빠르게 액세스할 수 있다.
    
    → 캐시가 많이 쌓이면 탐색 속도가 느려질 수 있어 정기적으로 캐시를 지워야 한다.
    
