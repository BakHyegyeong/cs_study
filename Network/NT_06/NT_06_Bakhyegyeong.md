# WebSocket

HTML5에 등장한 실시간 웹 애플리케이션을 위해 설계된 통신 프로토콜

- 서버와 클라이언트 간에 **양방향 통신**이 가능하다.
- 웹 앱과 서버 간의 **지속적인 연결**을 제공한다.
- **TCP를 기반**으로 한 신뢰성 있는 데이터 전송을 보장한다.
    
    → 연결 초기에 HandShake를 수행한다.
    
- 데이터가 패킷(packet) 형태로 전달된다.

![](https://user-images.githubusercontent.com/45002556/108620022-5964cb80-746c-11eb-8baf-ec8001bf79f5.png)

## HTTP

초기 인터넷 통신 방식으로 **클라이언트가 Request를 보내고 서버가 Response하는 단방향 통신 방식**

→ **클라이언트의 요청이 있을 때만 서버가 응답**하여 해당 정보를 전송하고 **곧바로 연결을 종료**하는 방식

![](https://user-images.githubusercontent.com/45002556/108620020-579b0800-746c-11eb-9051-18df4b2bf574.png)

## HTTP의 문제점

### HTTP는 실시간 통신이 아니다.

- **HTTP** : 클라이언트와 서버가 메시지를 **주고받을 때마다** 연결하고 종료
    
    → 실시간 통신을 위해서 **클라이언트는 새로운 데이터가 있는지 확인하기 위해 서버에 지속적으로 요청**을 보내야 한다.
    
    → 불필요한 트래픽 증가와 요청과 응답 사이의 지연시간 문제가 존재한다.
    
- **Socket** : 한번 연결을 하면 **메시지를 다 주고받기 전까지 종료하지 않고** 메시지를 다 주고받은 후에야 close를 통해 연결을 종료
    
    → **계속 연결을 유지하는 연결 지향형 통신**이기 때문에 실시간 통신이 필요한 경우에 자주 사용된다.
    

| 통신방법 | HTTP | Socket |
| --- | --- | --- |
| 연결 | data를 한번 주고받을 때마다 | data를 보내기 위한 connection을 맺을 때 |
| 종료 | data를 한번 주고받을 때마다 | client와 server가 data를 모두 다 주고받았을 때만 |

### HTTP는 단방향 통신이다.

클라이언트가 서버에 요청하지 않는 이상 **서버는 클라이언트에 먼저 데이터를 보낼 수 없다.**

→ HTTP 통신과 달리 Socket 통신은 **서버 역시 클라이언트로 요청을 보낼 수 있다.**

## WebSocket 이전의 통신 방식

### Polling

클라이언트가 **주기적으로 서버에 요청**을 보내는 방식

→ 일정 시간을 정해 놓고 새로운 데이터가 있는지 요청을 보내서 확인하는 방식이다.

![](https://blog.kakaocdn.net/dn/bScRjQ/btsCN0JhpiC/uxKKkOV0N7IoLEw5OQvzzk/img.png)

- 불필요한 request와 response를 생성한다.
    
    → 서버의 부담이 커진다.
    
- 요청과 응답 사이의 지연 시간이 발생해 실시간 정도의 빠른 응답을 기대할 수 없다.
- 실제 통신에서는 언제 통신이 발생할지 예측할 수 없기에 비효율적이다.

### Long Polling

Polling 방식과 동일하지만 클라이언트 요청 당시 새로운 데이터가 없다면 **일정 시간 동안 응답을 하지 않고 새로운 데이터가 있을 때까지 기다린 후 응답**을 보낸다.

![](https://velog.velcdn.com/images/melt/post/cda9842f-2dc4-4fdd-bc38-ec559061045d/image.png)

- 불필요한 request와 response를 생성한다.
    
    → 서버의 부담이 커진다.
    
- 요청과 응답 사이의 지연 시간이 발생해 실시간 정도의 빠른 응답을 기대할 수 없다.

### SSE (Server-Sent Event)

HTTP 통신을 종료하지 않고 연결을 유지하는 방식

**→ [서버 → 클라이언트]간의 단방향 통신**이다.

![](https://velog.velcdn.com/images/erictomi/post/074d96a3-accb-4e45-a788-fa7da45099fc/image.png)

- 클라이언트가 서버에 연결을 요청
- 서버가 요청을 확인한 후 새로운 데이터가 생길 때마다 클라이언트에게 응답을 전달

## WebSocket 사용법

```jsx
const socket = new WebSocket("ws://example/chat");
```

`ws`라는 특수 프로토콜을 사용한다.

→ `wss` 프로토콜도 존재하며 HTTP와 HTTPS의 관계와 유사하다.

### 소켓 이벤트

소켓이 정상적으로 생성되면 아래 이벤트를 사용할 수 있다.

- **open** – 연결이 **성공적**으로 되었을 때 발생
- **message** – 데이터를 **수신**하였을 때 발생
- **error** – 연결 상 **에러**가 생겼을 때 발생
- **close** – 연결이 **종료**되었을 때 발생

## WebSocket과 HTTP의 차이점

1. 프로토콜 : WebSocket은 연결 초기 HandShake에 HTTP를 사용하지만 그 후 통신은 ws라는 독자적인 프로토콜을 사용한다.
2. 사용처
    - HTTP : 게시판 같은 실시간 연결이 아닌, **필요한 경우에만 서버로 접근하는 콘텐츠 위주의 데이터**를 사용할 때 용이
    - WebSocket : 실시간 streaming 중계나 실시간 채팅과 같이 **즉각적으로 정보를 주고받는 경우**에 용이
3. 방향 통신
    - HTTP : 단방향 통신
    - WebSocket : 양방향 통신

## WebSocket 문제점

- 브라우저 지원 : 웹 소켓은 HTML5 사양의 일부이므로 HTML5를 지원하지 않는 브라우저에서는 사용할 수 없다.
- 서버 비용: 웹소켓은 한번 연결되면 별도의 에러나, 지시가 없는한 지속적인 연결을 유지하므로, 많은 수의 **웹소켓 연결을 동시에 관리하는 경우 서버의 부하가 증가**할 수 있다.
- 상세한 에러처리: 만약 연결이 끊어졌을 시 웹소켓은 연결이 끊어진 이유에 대해 정확히 알 수 없다.
- 재연결 처리 : **웹소켓은 자동으로 재연결을 진행하지 않기 때문**에 연결이 끊어지면 재연결할 수 있도록 처리를 한번 더 해야 한다.