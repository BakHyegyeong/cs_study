# **3-way Handshaking**

TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 **수신측과 사전에 세션을 수립하는 과정**

→ 이 과정을 통해 클라이언트와 서버 모두 **데이터를 전송할 준비가 되었다는 것이 보장**된다.

### 과정

![](/Network/NT_02/image.png)

1. 클라이언트가 서버에 접속을 요청하는 **syn 패킷을 전송**하고 **syn_sent 상태**가 되어 ack응답을 기다린다.

2. 서버는 **syn요청을 받고** 클라이언트에게 요청을 수락한다는 **ack와 syn flag**가 설정된 패킷을 발송하고 **syn_received**상태가 되어 ack 응답을 기다린다.

3. 클라이언트가 **syn+ack를 수신**한 후 서버에 다시 **ack를 보내면** 세션이 생성되고 이때부터 데이터가 전송된다.
    
    → 이때 서버와 클라이언트는 established상태가 된다.
    

- client : syn 전송 → syn_sent → syn+ack 수신 → 다시 ack 전송 → established
- server : syn 수신 → syn+ack 송신 → syn_received → ack 수신 → established

> ⭐
> 
> - SYN: Synchronize Sequence Numbers  
>   - TCP 헤더에서 플래그 비트(flag bit)의 SYN에 동기화 시퀀스 번호가 저장됩니다.  
>   - 양쪽이 보낸 **최초의 패킷에만 이 플래그가 설정**됩니다.  
>   - 직전에 보낸 ACK의 값으로 설정됩니다.  
>
> - ACK: Acknowledgment  
>   - TCP 헤더에서 플래그 비트(flag bit)의 ACK에 **직전 패킷의 시퀀스 넘버가 담겨** 패킷이 제대로 도착했는지 확인할 수 있습니다.  
>   - 클라이언트가 보낸 최초의 SYN 패킷 이후에 전송되는 모든 패킷은 이 플래그가 설정되어야 합니다.  


## ACK가 누락된다면?

### 송신자의 packet이 손실될 경우

TCP에서 송신자는 일정시간(time out) 동안 수신자의 피드백을 받지 못하면 **패킷을 재전송**한다.

![](https://steadiness.dev/static/3489b70fe836f0a7215ce2c7dcbf76c9/d2cbc/tcp-basic-03.png)

### **수신자의 ACK가 누락된다면?**

1. 송신자(A)는 데이터를 수신자(B)에게 전달한다.
2. 수신자(B)는 ACK를 송신자(A)에게 전송하지만 전달되지 못한다.
3. 송신자(A)는 수신자(B)로부터 ACK를 전달받지 못하고, 일정 시간 이후 재전송을 시도한다.

**→ 수신자는 중복된 데이터를 받게 된다.**

→ TCP의 세그먼트마다 **Sequence Number**를 부여해 중복을 확인한다.

![](https://steadiness.dev/static/0624e7c7a4a4f09d055309e10c4a8556/d2cbc/tcp-basic-05.png) 

## 4-way Handshaking

세션을 종료하기 위해 수행되는 절차

### 과정

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqUXSw%2FbtqDWsFNWJw%2FhVdKIneSYb7UK3wc0pj6Z0%2Fimg.png)

1. 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송하고 **FIN_WAIT** 상태가 된다.
2. 서버는 확인 메시지를 보내고 **CLOSE_WAIT** 상태가 되어 자신의 통신이 끝날 때까지 기다린다.
3. 서버가 통신이 끝났으면 연결이 종료되었다는 의미의 FIN 플래그를 클라이언트에게 전송한다.
    
    → 클라이언트는 FIN_WAIT에서 **TIME_WAIT** 상태로 변경된다.
    
4. 클라이언트는 확인했다는 메시지를 보낸다.

### TIME_WAIT 상태

Server로부터 FIN을 수신하더라도 **일정시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정**

→ Server에서 FIN을 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 **FIN패킷보다 늦게 도착하는 상황에 대비하기 위해서 필요**하다.

→ Client에서 세션을 종료시킨 후 뒤늦게 도착하는 **패킷은 Drop되고 데이터는 유실**되기 때문이다.

# 흐름 제어

송신 측과 수신 측의 **데이터 처리 속도 차이를 해결하기 위한 기법**

→ **송신측의 데이터 전송량을 수신측의 처리량에 따라 조절**한다.

## 슬라이딩 윈도우 방식

**송신 버퍼의 범위를 동적으로 조절**함으로써 흐름제어를 수행하는 방법

→ 수신 측에서 설정한 윈도우 크기를 **송신 측에서 확인 응답 없이 프레임을 전송**할 수 있게 하여 **데이터 흐름을 동적으로 조절하는 제어 기법**

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc0lAeU%2FbtqCQnMp1lS%2FQiINTLkYkkkZyeG2a7rnCk%2Fimg.png)

1. 송신 측에서 **초기 윈도우 크기 내에서 프레임을 전송**
    
    → 보낸 크기만큼 윈도우의 왼쪽 경계를 줄인다.
    
2. 수신 측에서 데이터를 정상적으로 수신했음을 알리는 ACK를 전송
    
    → 송신측에서 이를 확인하고 이 **ACK의 프레임 수만큼 다시 오른쪽으로 윈도우의 경계를 확장**
    

> ⭐
> 
> 윈도우 : 전송, 수신 스테이션 양쪽에서 만들어진 버퍼의 크기를 의미 <br>
> → 윈도우의 크기가 아닌 윈도우의 경계를 조절함으로써 이루어진다. 


### 윈도우의 크기

윈도우의 크기는 네트워크 환경에 따라서 적절하게 조정해야 한다.

→ 속도가 느리거나 트래픽이 높은 네트워크 환경이라면 데이터 전송이 오래 걸리므로 **윈도우의 크기가 커지면 ACK가 최대 전송 시간을 초과해서 도착하지 않을 수도 있다.**

→ 재전송이 필요하게 되고 이에 따라서 **성능이 저하**된다.
