# 소프트웨어 공학

소프트웨어를 개발하는 과정에서 발생하는 문제를 해결하기 위한 학문

- 목표 : **고품질의 소프트웨어**를 효율적으로 개발하고, **비용과 시간을 절약**하여 **납기일을 지켜** 소프트웨어 프로젝트를 성공적으로 완료하는 것
    
    ![](https://velog.velcdn.com/images/lmlabs/post/ef0f6e29-d4fe-4913-8023-361b996eecf7/image.png)
    

- **SWEBOK(Software Engineering Body of Knowledge)** : 소프트웨어 공학의 학문적인 내용을 정리한 것

## **SDLC(Software Development Life Cycle)**

SW 개발 생명 주기로써 소프트웨어 개발의 전 과정을 의미한다.

> 계획 → 요구 분석 → 설계 → 구현 → 테스트 → 배포 → 유지보수

## 프로세스

소프트웨어 개발을 위한 일련의 절차와 활동

→ 개발 생명 주기를 어떠한 절차로 진행할 것인지를 의미한다.

- 폭포수 모델 : 가장 오래되고 전통적인 프로세스 모델로 개발 생명주기를 단계적으로 수행하는 모델
- 프로토타입 모델 : 요구 분석 단계에서 사용자의 초기 요구사항을 파악해 **프로토타입을 만들고** 고객 평가를 통해 프로토타입에 대한 조정 과정을 거쳐 요구 사항과 구현의 간극을 줄일 수 있도록 설계된 모델
- 나선형 모델 : 요구 분석 → 위험 분석 → 개발 → 사용자 평가 과정을 반복하며 점진적으로 개발하는 모델
- UP : UML을 기반으로 하는 객체지향 소프트웨어 개발 프로세스
- 애자일 모델 : **현재의 대표적인 프로세스 모델**
    - SW개발의 궁극적인 목표는 고객이 만족하는 소프트웨어를 개발하는 것이다.
    - 동작 가능한 소프트웨어를 짧으면 2주, 길어도 2개월 이내로 개발하고 고객의 피드백을 수용하여 개발한다.
    - 프로세스가 진행되는 동안 고객과 개발자가 지속적으로 소통하며 요구사항의 변화에 유연하게 대처한다.
    - 빠른 프로토타이핑과 반복적이고 잦은 출시를 목표로 한다.

## 방법론

프로세스를 수행하기 위한 구체적인 방법

→ 프로세스를 수행하기 위한 접근법과 원칙, 철학

- 객체지향 분석 및 설계(Object Oriented Analysis and Design) : 프로그램을 객체와 객체간의 인터페이스 형태로 구성하기 위해 문제 영역에서 **객체, 클래스 및 이들 간의 관계를 식별해 설계 모델로 변환**하는 방법론
    
    ![](https://www.albks.com/lecture/sweng/chapters/img/ch1-4.png)
    
    
- 스크럼 : 애자일 방법론 중 하나로 프로젝트를 여러 개의 **반복적인 개발 주기인 스프린트(Sprint)** 로 나누어 진행하는 방법론

## 좋은 소프트웨어

- 유지 가능성 : 소프트웨어는 변화하는 상황 속에서 고객의 요구사항에 맞춰 진화할 수 있어야 한다.
- 신뢰성과 보안 : 소프트웨어는 물리적, 경제적 손해를 유발하면 안된다.
- 효율성 : 처리 시간, 메모리 사용에 있어서 효율적인 관리가 되어야 한다.
- 접근 가능성 : 개발된 소프트웨어는 반드시 이해할 수 있어야 하며 유용해야 한다.


# 형상 관리

소프트웨어의 변경사항을 **체계적으로 추적하고 통제**하는 것

→ 일반적인 단순 버전관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술분야의 형태로 넓히는 근간


![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbhv0li%2FbtrqMv1rfqM%2FWsxiRXP1X6JWYZC0KAcXrK%2Fimg.png)

## 버전 관리

형상관리 중에 문서, 소스코드 등 버전을 관리해주는 버전 관리 시스템

→ 일반적으로 형상관리를 버전관리라고 생각한다.

- **변경점 관리 :** 여러 사용자들이 release한 시점을 관리
- **버전 관리 :** 특정 시점에 꼬리표(Tag)를 달아 버전을 표시, 브랜치(branch)로 여러 버전을 개발 가능하다.
- **백업&복구 :** 버전 관리를 통해서 복구 또는 다른곳으로 백업을 가능하게 한다.
- **협업 :** 개별 사용자의 수정사항을 쉽게 공유할 수 있다.

## 버전 관리 종류

### 로컬 버전관리시스템 (VCS: Version Control System)

- Patch Set : 파일에서 변경되는 부분
- Patch Set을 특정한 형식의 파일로 저장한다.
- 이 Patch Set을 통해서 모든 파일을 특정 시점으로 되돌릴 수 있다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc24onT%2FbtrqHTP4flJ%2FcXM3MhHUb6kUkkrYqrO41k%2Fimg.png)

### 중앙집중식 버전관리시스템 (CVCS: Centralized VCS)

SVN(Subversion), CVS(Concurrent Versions System), Perforce 등이 이에 해당한다.

- 하나의 중앙 서버와 여러 클라이언트가 파일을 받아서 사용한다.
- 장점
    - 관리자가 사용자들을 관리하기 용이하다.
    - 중앙 서버의 VSC 하나만 관리하면 된다.
- 단점 : 중앙 서버가 문제가 생기면 협업에 문제가 생기며, 중앙 데이터베이스에 문제가 생기면 모든 히스토리를 잃어 버린다.
    
    

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbplU9k%2FbtrqNMO3DpC%2FYP9EzKzt11NMvsmt0mMpK1%2Fimg.png)

### 예시

- CVS : 가장 오랫동안 사용되었던 형상관리 도구로 안정적이다.
    - 중앙에 위치한 Repository에 파일 저장하고 모든 사용자가 파일에 접근 할 수 있다.
    - 파일 관리 중 롤백이 되지 않는다.
    - 아스키코드를 지원하며 유니코드는 제한적으로 지원한다.
    - 속도가 상대적으로 느리다.

- SVN : CVS의 단점을 보완하기위해 만들어졌으며 중앙관리만을 지원한다.
    - 파일 단위가 아닌 change set을 커밋 단위로 하여 다른사용자의 커밋과 엉키지 않고 롤백 기능을 지원한다.
    - 처리속도가 CVS에 비해 상대적으로 빠르다.
    - 잦은 커밋으로 리비전 번호가 크게 증가할 수 있으면 개별 이력을 관리할 수 없다.

### 분산 버전관리시스템(DVCS: Distributed VCS)

Git, Mecurial, Bazaar, Darcs 등이 이에 해당된다.

- 클라이언트가 저장소와 히스토리를 전부 복제(Clone)한다.
- 서버에 문제가 생겨도 복구가 가능하다.
- 원격 저장소가 존재하며 다양한 그룹과 협업이 가능하다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHyNjf%2FbtrqIrMUMgR%2FV0Z44xSNsdqAKVrwbg0A2K%2Fimg.png)

### 예시

- GIT : 매우 빠른 속도를 가지고 있으며 분산형 관리 시스템을 가지고 있다.
    - 다른 형상관리 도구에 비해 다양한 기능을 지원한다.
    - 로컬 관리와 중앙 관리가 모두 가능하다.
    - 장소에 구애받지 않고 협업이 가능하다.
