# 형상 관리 도구

## 중앙집중식 버전관리시스템 (CVCS: Centralized VCS)

하나의 중앙 서버와 여러 클라이언트가 파일을 받아서 사용한다.

- 장점
    - 관리자가 사용자들을 관리하기 용이하다.
    - 중앙 서버의 VSC 하나만 관리하면 된다.
- 단점 : 중앙 서버가 문제가 생기면 협업에 문제가 생기며, 중앙 데이터베이스에 문제가 생기면 모든 히스토리를 잃어 버린다.

### 예시

- CVS : 가장 오랫동안 사용되었던 형상관리 도구로 안정적이다.
    - 중앙에 위치한 Repository에 파일 저장하고 모든 사용자가 파일에 접근 할 수 있다.
    - 파일 관리 중 롤백이 되지 않는다.
    - 아스키코드를 지원하며 유니코드는 제한적으로 지원한다.
    - 속도가 상대적으로 느리다.

- SVN : CVS의 단점을 보완하기위해 만들어졌으며 중앙관리만을 지원한다.
    - 파일 단위가 아닌 change set을 커밋 단위로 하여 다른사용자의 커밋과 엉키지 않고 롤백 기능을 지원한다.
    - 처리속도가 CVS에 비해 상대적으로 빠르다.
    - 잦은 커밋으로 리비전 번호가 크게 증가할 수 있으면 개별 이력을 관리할 수 없다.

## 분산 버전관리시스템(DVCS: Distributed VCS)

Git, Mecurial, Bazaar, Darcs 등이 이에 해당된다.

- 클라이언트가 저장소와 히스토리를 전부 복제(Clone)한다.
- 서버에 문제가 생겨도 복구가 가능하다.
- 원격 저장소가 존재하며 다양한 그룹과 협업이 가능하다.

### 예시

- GIT : 매우 빠른 속도를 가지고 있으며 분산형 관리 시스템을 가지고 있다.
    - 다른 형상관리 도구에 비해 다양한 기능을 지원한다.
    - 로컬 관리와 중앙 관리가 모두 가능하다.
    - 장소에 구애받지 않고 협업이 가능하다.

## Git을 사용해야 하는 이유

- **변경점 관리 :** 여러 사용자들이 release한 시점을 관리
- **버전 관리 :** 특정 시점에 꼬리표(Tag)를 달아 버전을 표시, 브랜치(branch)로 여러 버전을 개발 가능하다.
- **백업&복구 :** 버전 관리를 통해서 복구 또는 다른곳으로 백업을 가능하게 한다.
- **협업 :** 개별 사용자의 수정사항을 쉽게 공유할 수 있다.

# Git branch 전략

**여러 개발자가 하나의 저장소에 작업**을 할 때, 협업을 좀 더 효과적으로 하기 위해 **git branch 에 대한 규칙**을 정하고 저장소를 잘 활용하기 위한 **workflow 를 정의**하는 것

## branch

독립적으로 어떤 작업을 진행하기 위한 개념으로 **다른 branch의 영향을 받지 않는다.**

→ **여러 기능을 여러 사람이 병렬적으로 개발**할 수 있게 된다.

### branch가 없다면?

- 메인 branch에 바로 커밋이 되면서 기능이 완성되기 전까지 메인 branch는 불완전한 상태로 존재하게 된다.
    
    → 메인 branch는 출시와 배포를 위한 branch이므로 옳지 않다.
    
- 다른 개발자가 작업 중인 파일을 건드릴 수 있게 되어 작업이 꼬이게 된다.
- 커밋 히스토리가 메인 branch에 섞이게 된다.
    
    → 원하는 시점으로 **롤백하기 어려워진다.**
    

## Git Flow 전략

![](https://devocean.sk.com/editorImg/2023/12/15/6c564810665399f6549ed2bffc7e763c7e39f5fab128a3442ddeb44ee6593c04)

- **main** : 기준이 되는 브랜치로 제품을 배포하는 브랜치
- **develop** : 개발 브랜치로 개발자들이 이 브랜치를 기준으로 각자 작업한 기능들을 Merge한다.
- feature : 단위 기능을 개발하는 브랜치로 기능 개발이 완료되면 develop 브랜치에 Merge한다.
- release : 배포를 위해 main 브랜치로 보내기 전에 먼저 QA(품질검사)를 하기위한 브랜치
- hotfix : main 브랜치로 배포 후 버그가 생겼을 떄 긴급 수정하는 브랜치

### 과정

1. main 브랜치에서 develop 브랜치를 분기한다.
2. 기능 구현을 위해 develop 브랜치에서 feature-* 브랜치를 분기한다.
3. 작업이 완료된 feature-* 브랜치를 develop 브랜치로 병합한다.
4. 배포를 준비하기 위해 develop 브랜치에서 release-* 브랜치를 분기한다.
5. 테스트를 진행하면서 발생하는 버그 수정은 release-* 브랜치에 직접 반영한다.
6. 테스트가 완료되면 release 브랜치를 main 브랜치에 merge한다.
7. 배포 이후 release 브랜치에서 발견되지 못한 버그들은 hotfix 브랜치로 분기해 바로 반영한다.

## Github Flow 전략

base 브랜치인 **main 브랜치**와 기능을 추가하기 위한 **feature 브랜치**만으로 운영해 **빠른 수정 배포**를 가능하게 하는 전략

![](https://velog.velcdn.com/images%2Fkw2577%2Fpost%2F84a8ea75-018e-4d04-a879-440065e24e6b%2Fimage.png)

- main : 기준이 되는 브랜치로 제품을 배포하는 브랜치
    - 항상 stable한 상태여야 한다.
- feature : 새로운 기능을 개발하는 브랜치
    - Git Flow의 Feature 브랜치와 동일한 역할
    - 버그 수정도 함께 진행
    - 브랜치의 이름은 기능을 설명하는 명확한 이름으로 네이밍 해야 한다.
    - PR을 통해 개발자들 간의 코드 리뷰 후 동의를 얻어 main 브랜치에 merge 된다.

### 과정

1. 신규 기능 개발이 필요할 때 main 브랜치에서 feature 브랜치를 따서 작업을 진행한다.
2. 작업이 완료되면 Pull Request 를 생성하여 Review 를 요청한다.
3. 리뷰가 완료되고, 피드백이 모두 반영되면 해당 feature 브랜치를 main 브랜치로 Merge 한다.

### Git Flow VS Github Flow

|  | Git Flow | Github Flow |
| --- | --- | --- |
| 브랜치 수  | 다양한 종류의 브랜치 | 2개의 브랜치 |
| 배포 방식 | release와 hotfix 브랜치를 통한 배포 절차 | main브랜치에서 배포를 수행하며 단순하며 지속적인 배포 |
| 안전성 | 더 많은 제어와 복잡한 브랜치로 배포 안전성과 버전 관리 및 롤백 등의 체계적이고 안전한 운영이 가능하다. | 테스트와 검증 절차를 거치지 않고 main 브랜치에 merge되므로 위험하다. |
| 사용처 | 복잡한 프로젝트나 대규모 팀 | 단순하며 빠른 개발 및 배포를 위한 프로젝트 |

## Gitlab Flow 전략

복잡한 Gitflow와 너무 간단한 Github의 절충안으로 나온 전략이다.

![](https://velog.velcdn.com/images%2Fkw2577%2Fpost%2F313e0249-742a-4abb-a97e-e2b6e579edaf%2Fimage.png)

- production : 제품을 배포하는 브랜치
    
    → 오로지 배포만을 담당한다.
    
- pre-production : 병합되기 전 테스트를 수행하는 브랜치
- main : 기준이 되는 브랜치로 production 브랜치에 merge된다.
- feature : 단위 기능을 개발하는 브랜치로 기능 개발이 완료되면 main 브랜치에 Merge된다.

## Fork와 Pull Request

규모가 있는 개발의 경우 브랜치 보다는 **Fork와 Pull requests를 활용**해 진행한다.

- 프로젝트 자체를 외부로 복제해서 개발을 하는 방식이다.
- 개발 후 브랜치처럼 merge를 하는 것이 아닌 Pull Request로 관리자에게 merge 요청을 보낸다.
    
    → 후에 관리자가 Pull Request를 본 후 승인 또는 거절을 하는 방식으로 진행된다.
    
![](https://velog.velcdn.com/images%2Fkw2577%2Fpost%2F61f4c802-4e8d-41d8-b1d7-18ba8dfdff5c%2Fimage.png)