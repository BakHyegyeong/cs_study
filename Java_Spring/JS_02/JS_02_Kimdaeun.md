# JVM 메모리 영역의 구성

## JVM 메모리 구조

```plaintext
+-----------------------+
|       Method Area     |  <-- 클래스-level 데이터, static 변수
+-----------------------+
|         Heap          |  <-- 객체, 배열
+-----------------------+
|         Stack         |  <-- 메서드 호출 시 지역 변수, 매개변수
+-----------------------+
|     PC Register       |  <-- 명령어 위치 추적
+-----------------------+
| Native Method Stack   |  <-- 네이티브 코드 실행 관련
+-----------------------+
```
## 1. **Method Area (메서드 영역)**
- 클래스 레벨 데이터와 관련된 정보를 저장하는 영역
- JVM이 로드한 모든 클래스의 **메타데이터**(클래스 이름, 메서드 정보, 변수 정보 등)를 저장한다.
- **Static 변수**와 **상수(Constant Pool)**도 이 영역에 포함된다.
- JVM 시작 시 생성되며, 모든 스레드에서 공유됩니다.  

## 2. **Heap (힙 영역)**
- JVM에서 동적으로 생성한 객체와 배열이 저장되는 영역
- 모든 스레드가 서로 공유하는 영역이다.
**구성** :
  - **Young Generation**
    - Eden 영역 : 새롭게 생성된 객체가 저장되는 영역.
    - Survivor 영역 : GC 후 살아남은 객체가 저장되는 영역.
  - **Old Generation** : Young Generation에서 오래 살아남은 객체가 이동되는 영역.  
- 객체를 관리하고, 대부분의 가비지 컬렉션 작업이 이 영역에서 이뤄진다.
- 메모리가 부족하면 `OutOfMemoryError: Java Heap Space`가 발생

## 3. **Stack (스택 영역)**
- 각 스레드별로 생성되고, 메서드 호출 시 **지역 변수, 매개변수, 리턴값** 등을 저장한다.
- 메서드가 호출되면 스택 프레임이 생성되고, 메서드가 종료되면 스택 프레임이 제거된다.
- **스레드별로 독립적인 공간**
- 컴파일 타임에 크기가 결정되는 값이 저장
- 메모리가 부족하면 `StackOverflowError`가 발생

## 4. **PC Register (프로그램 카운터 레지스터)**
- 각 스레드가 실행할 **명령어의 주소**를 저장
- **스레드별로 독립적**으로 생성
- 현재 실행 중인 명령어의 위치를 추적
- 자바 바이트코드가 아닌 네이티브 메서드를 실행하는 경우 이 영역이 비어있을수도 있다.

## 5. **Native Method Stack (네이티브 메서드 스택)**
- 자바 외부에서 실행되는 네이티브 코드(C, C++ 등)와 관련된 메모리 영역 
- JNI(Java Native Interface)를 통해 호출된 네이티브 메서드의 실행에 사용
- 스레드별로 생성
- 메모리가 부족하면 `StackOverflowError`가 발생

