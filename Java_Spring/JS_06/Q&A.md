## Q1. Call by Value와 Call by Reference에 대해 설명해주세요.
- Call by Value 
  - 함수 호출 시 값 자체를 복사하여 전달하는 방식입니다. 
  - 복사된 값은 함수 내부에서 사용되며, 원본 데이터에는 어떠한 영향도 미치지 않습니다.
- Call by Reference 
  - 데이터의 참조(메모리 주소)를 전달하는 방식입니다. 
  - 이 경우 함수 내부에서 데이터를 변경하면, 원본 데이터에도 동일하게 반영됩니다.

## Q2. Call by Value로 전달된 객체의 내부 필드를 수정하면 어떻게 되나요?
- Call by Value에서는 객체의 참조 값(주소)이 복사되어 전달됩니다. 따라서, 함수 내부에서 복사된 참조 값을 통해 객체의 내부 필드를 수정하면, 이 변경은 원본 객체에도 영향을 미칩니다. 하지만, 함수 내부에서 새로운 객체를 생성하거나 참조를 변경해도, 원본 참조에는 영향을 주지 않습니다.

## Q3. Call by Value와 Call by Reference는 각각 어떤 상황에서 유리할까요?
- Call by Value 
  - 원본 데이터를 보호해야 하는 상황에서 유리합니다. 
  - 값 복사가 간단하고 빠른 경우, 특히 작은 크기의 기본 데이터 타입을 다룰 때 적합합니다.
- Call by Reference 
  - 데이터 크기가 크거나, 데이터를 복사하는 데 비용이 높은 경우 효율적입니다. 
  - 함수 내부에서 원본 데이터를 직접 수정해야 할 때 적합합니다.

## Q4. Java는 어떤 전달 방식을 사용하는지
- Java는 오로지 Call by Value만 사용한다. 
- 참조형의 경우 객체의 주소값을 전달하기에 Call by Reference 방식으로 생각할 수 있지만 실제로는 주소값이 주소를 가리키는 참조값이고 이 참조값 또한 전달할 때 복사해서 전달한다. 
- 즉 Java에서 기본형(원시값)은 값 자체를 복사하고 참조형은 참조 값을 복사한다.

## Q5. 기본형은 어떤 메모리에 저장되는가
- 기본형, 원시 변수는 메서드의 인자로 전달받을 때 직접 스택 메모리에 할당된다. 이 매개변수는 해당 메서드가 실행되는 동안에만 지속되며 반환 시 스택에서 지워지게 된다.

## Q3. 참조형은 어떤 메모리에 저장되는가
- 참조 변수는 스택 영역에 저장되고 참조되는 객체는 힙 영역에 저장된다. 
- 참조되는 객체의 값에는 변화가 생길 수 있지만 참조 변수의 값은 주소값으로 그대로이다.

## Q4. Python은 어떤 전달 방식을 사용하는가 / C, C++은 어떤 전달방식을 사용하는가
- Passed by Assignment, Call by object-reference 방식을 사용한다. 여기에서 넘겨지는 객체의 종류에 따라서도 나뉘어진다.
- C는 오로지 Call by Value 방식을 사용한다. / C++은 Call by Value, Call by Address, Call by Reference 방식을 사용한다.

## Q5. 배열과 연결 리스트 시간 복잡도
| 연산 종류      | 배열 시간 복잡도                  | 연결 리스트 시간 복잡도     |
|---------------|----------------------------|-------------------|
| 삽입/삭제      | O(n)                       | O(1). 최악의 경우 O(n) |
| 조회 | 임의 접근시, O(1), 순차 접근 시 O(n) | O(n)              |

## Q6. 연결리스트 배열 개념.
- 연결리스트
  - 불연속적인 메모리를 갖고 있으며, 노드와 포인터로 이루져 있다.
  - 포인터가 참조 정보를 갖고 있어, 메모리를 많이 사용하지만 가변적인 데이터를 다룰 때 좋다. 
  - 삽입/삭제시 강점을 갖고 있다.
- 배열 
  - 연속적인 메모리 구조를 갖고 있다.
  - 인덱스를 통해 조회시 강점을 가진다.
