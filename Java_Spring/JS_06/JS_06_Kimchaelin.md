# Call by Value와 Call by Reference의 차이
- 프로그래밍에서 함수 호출 시 인자를 전달하는 방식 두가지.
## Call by Value
<img src="https://user-images.githubusercontent.com/41438361/87274841-b03e1600-c517-11ea-804d-861255b66975.png" width="50%">

- 함수가 인자로 전달받은 값을 복사하여 처리하는 방식
- 함수는 전달받은 값을 복사한 새로운 메모리 공간에서 작업을 수행하므로 원래의 값에 영향을 주지 않음.
- 기본적으로 많은 언어에서 사용됨 (예: Java에서 기본 자료형).
- 장점
    - 복사하여 처리하므로 원래의 값이 보존이 된다.
- 단점
    - 복사를 하기 때문에 메모리 사용량이 늘어난다.

## Call by Reference
<img src="https://user-images.githubusercontent.com/41438361/87274967-0b700880-c518-11ea-939d-e41a35ddf1f4.png" width="50%">

- 함수가 인자로 전달받은 값의 주소를 참조하여 처리하는 방식
- 함수는 전달된 참조를 통해 원래 메모리 공간에 직접 접근하여 작업을 수행하므로 원래의 값에 영향을 줄 수 있다.
- 포인터 또는 참조를 지원하는 언어에서 주로 사용됨 (예: C++, Python에서 mutable 객체).
- 장점
    - 대량의 데이터를 전달시, 복사를 하지 않기 때문에 메모리 사용량이 적고 성능이 좋음
- 단점
    - 원래의 값이 의도치 않게 변경될 수 있어 디버깅이 어려워질 수 있음.

# 배열과 연결 리스트의 차이

## 배열
- 배열은 연속된 메모리 공간에 데이터를 저장하는 자료구조(정적인 자료구조)
- 처음에 배열의 크기를 정해놓고 사용해야 하며, 크기를 변경할 수 없음
- 인덱스를 통해 임의접근 가능(시간복잡도 O(1))
- 데이터의 삽입, 삭제 시 다른 데이터를 이동해야 하므로 최악의 경우 O(n)의 시간복잡도를 가짐

## 연결 리스트
- 연결 리스트는 불연속적인 메모리 공간에 데이터를 저장하는 자료구조(동적인 자료구조)
- 노드를 추가할 수 있어, 크기를 동적으로 변경할 수 있음
- head부터 순차적으로 탐색해야 하므로 시간복잡도 O(n)
- 데이터의 삽입, 삭제 시 해당 인덱스를 O(n)으로 찾으면, 배열과 달리 다른 데이터를 이동할 필요가 없이, O(1)의 시간복잡도를 가짐
- 포인터를 사용하여 다음 노드의 주소를 가리키기 때문에 메모리 사용량이 더 큼

| 구분       | 배열                  | 연결 리스트               |
|------------|-----------------------|---------------------------|
| 메모리 공간 | 연속된 메모리 공간   | 불연속적인 메모리 공간    |
| 크기       | 정해져 있음           | 동적으로 변경 가능        |
| 탐색       | O(1)                 | O(n)                     |
| 삽입, 삭제 | O(n)                 | O(1)                     |

## 사용
- 배열 : 데이터 크기가 변하지 않고, 임의접근이 빈번할 때.
- 연결 리스트 : 데이터 크기가 변하거나, 삽입, 삭제가 빈번할 때.
