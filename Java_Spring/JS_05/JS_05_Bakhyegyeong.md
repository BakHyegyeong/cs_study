# 접근 제어자 종류와 차이

## 접근 제어자

: 클래스, 인터페이스, 클래스나 인터페이스가 가진 멤버에 대한 접**근을 제한**하기 위해 사용된다.

- **public 접근 제한자 :** 단어 뜻 그대로 **외부 클래스가 자유롭게** 사용할 수 있도록 한다.
- **protected 접근 제한자 :** **같은 패키지 또는 자식 클래스**에서 사용할 수 있도록 한다.
- **default 접근 제한 :** **같은 패키지에 소속된 클래스에서만** 사용할 수 있도록 합니다.
    
    → 다른 세 가지 접근 제한자가 적용되지 않으면 자동으로 default 접근 제한을 가진다.
    
- **private 접근 제한자 :** 단어 뜻 그대로 개인적인 것이라 **외부에서 사용될 수 없도록** 한다.

![](https://velog.velcdn.com/images/kjyeon1101/post/61252075-5eb7-45ec-82a5-389a4ee48b6f/image.png)


![](https://hongong.hanbit.co.kr/wp-content/uploads/2021/09/01-자바의-접근-제한자_public_private-800x411.png)

### 접근 제어자 사용 이유

프로그램은 개발자가 프로그래밍 한대로 돌아가게 하는것을 목적으로 한다. 그런데 객체를 사용하는 사용자 입장에서 객체 내부적으로 사용하는 변수나 메서드에 접근하게 되면 **개발자가 의도하지 못한 오동작을 일으킬 확률이 높다.** 그렇기에 접근제어자를 사용해서 로직이 망가지는것을 방지하는 것이다.

또한, 프로그램의 규모가 커질수록 접근제어자를 사용함으로써 **코드의 관리가 편리해진다.** 변수나 메서드가 private하면 클래스의 외부에서 접근할 수 없다는것을 알고 있다. 그렇기에 코드를 수정할때 더 적은 범위에만 신경을 쓸 수 있다.

- 클래스와 인터페이스를 다른 패키지에서 사용하지 못하도록 막을 때
- 객체 생성을 막기 위해 생성자를 호출하지 못하게 할 때
- 필드나 메소드를 사용하지 못하도록 막아야 할 때

## 클래스의 접근 제어자

**public, default** 접근 제한을 가진다.

![](https://hongong.hanbit.co.kr/wp-content/uploads/2021/09/02-java_public_class_private_class-e1630984380551.png)

## 생성자의 접근 제어자

**public, protected, default, private** 접근 제한을 가진다.

![](https://hongong.hanbit.co.kr/wp-content/uploads/2021/09/05-자바-생성자의-접근-제한-public-private-e1630984935430.png)

## 필드와 메서드의 접근 제한
**public, protected, default, private** 접근 제한을 가질 수 있다.

![](https://hongong.hanbit.co.kr/wp-content/uploads/2021/09/06-자바-필드와-메소드의-접근-제한-800x175.png)

## 정리

| 접근 제한 | 적용 대상 | 접근할 수 없는 클래스 |
| --- | --- | --- |
| public | 클래스, 필드, 생성자, 메소드 | 없음 |
| protected | 필드, 생성자, 메소드 | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
| default | 클래스, 필드, 생성자, 메소드 | 다른 패키지에 소속된 클래스 |
| private | 필드, 생성자, 메소드 | 모든 외부 클래스 |


<br>

---

# 자바의 컴파일 과정 + 런타임 환경

- 컴파일 과정
![](https://camo.githubusercontent.com/4305def02d4ac05b046a5092f0f73b19c54da449eb128b0361858322acc80af1/68747470733a2f2f76656c6f672e76656c63646e2e636f6d2f696d616765732f63616c6c613334393471686b2f706f73742f32656438316439302d623039342d346135332d393631652d3134386538376664613066622f696d6167652e706e67)

- 컴파일 + 런타임 과정
![](https://tcpschool.com/lectures/img_java_programming.png)

1. 개발자가 자바 소스코드(.java)를 작성한다.
2. 자바 컴파일러가 자바 소스코드(.java)파일을 읽어 바이트코드(.class)코드로 컴파일 한다. 
    
    → 바이트코드(.class)파일은아직 컴퓨터가 읽을 수 없는 JVM(자바 가상 머신)이 읽을 수 있는 코드이다. 
    
3. 컴파일된 바이트코드(.class)를 JVM의 클래스로더(Class Loader)에게 전달한다.
4. 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Area의 Method Area), 즉 JVM의 메모리에 올린다.
5. 실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다. 
    - **인터프리터** : 바이트 코드 명령어를 **하나씩 읽어서 해석**하고 실행하는 방식
        
        → 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점을 가진다.
        
    - **JIT컴파일러** : 인터프리터 방식으로 실행하다가 **적절한 시점(자주 사용되는 코드)에 바이트 코드 전체를 컴파일**하여 바이너리 코드로 변경 후 바이너리 코드로 직접 실행하는 방식
        
        → 하나씩 인터프리팅하여 실행하는 것이 아니라 **바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것**이고 **변환된 기계어를 캐싱**할 수 있어 속도가 빠르다. 
        
        → 한번 변환된 기계어는 다시 변환할 필요가 없어 효율적이다.
        