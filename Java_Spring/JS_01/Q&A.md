## Q1. 가비지 컬렉션이란 무엇인가요?
더이상 참조되지 않는 객체를 JVM이 자동으로 메모리에서 제거하는 메모리 관리 메커니즘이다.

## Q2.  Stop-the-World란 무엇인가요?
가비지 컬렉션이 실행되는 동안 가비지 컬렉션을 수행하는 스레드를 제외하고 모든 스레드가 다 실행을 멈추는 것을 의미한다.

## Q3. 가비지 컬렉터(Garbage Collector) 작동의 문제를 진단하는 방법과 해결 하는 방법은?
- 가비지 컬렉터가 너무 오래 자주 실행될 경우 CPU 사용량이 급격하게 늘어나므로 이것을 모니터링
- 가비지 컬렉터가 제대로 수행되지 못하면 메모리 회수가 되지 않으므로 OutOfMemory오류가 발생을 확인
- GC 로그를 확인해 가비지 컬렉터가 어떤 자원을 회수했는지 등의 정보를 보고 확인
- **Survivor 영역 중 하나는 반드시 비어 있는 상태** 로 남아 있어야 하기 때문에 두 Survivor 영역에 모두 데이터가 1개 이상 존재하거나, 두 영역 모두 사용량이 0이라면 시스템이 정상적인 상황이 아니라고 판단할 수 있다.

## Q4. 가비지 컬렉션 특징
1. 기존 C에선 개발자가 메모리 해제했어야 했는데 자바에선 이것을 대신해준다.
2. 가비지 컬렉션이 메모리 관리하는 프로세스이며, 해당 일을 가비지 컬렉터가 수행한다.
3. 메모리 누수를 방지하며, 메모리를 효율적으로 사용할 수 있다.
4. 언제 메모리 해제가 되는지 알 수 없으며, 가비지 컬렉션 실행 시간 동안 모든 스레드가 멈춰, 프로그램의 성능에 영향을 줄 수 있다.
7. 메모리를 해제할지 결정하는 비용이 든다.

## Q5. 힙 영역 소개
1. **Young 영역:** 에덴 영역 - 새로운 객체가 적재되는 영역, 서바이버 영역 - 살아남은 객체가 이동하는 영역
2. **Old 영역:** 가비지 컬렉션으로부터 오랫동안 살아남은 객체가 이곳에 적재
3. **Permanent 영역:** 응용프로그램에서 사용되는 클래스와 함수를 설명하기 위한 메타데이터를 보관하는 영역 (이젠 사라짐)

## Q6. Mark and Sweep이란?
- **Mark:** 사용 중인 객체들을 마크하여, 사용되지 않는 객체를 식별하는 작업
- **Sweep:** Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업
- **Compact:** 해제된 후 살아남은 메모리를 한 곳으로 몰아서 메모리를 확보함
- 메모리 단편화를 최소화하고 성능을 향상 시킴

## Q7. Minor GC의 동작 과정
Young 영역은 1개의 Eden 영역과 2개의 Survivor 영역으로 이루어져 있다.

- **Eden 영역:** 새로 생성된 객체가 할당(Allocation)되는 영역
- **Survivor 영역:** 최소 1번의 GC 이후 살아남은 객체가 존재하는 영역

### 동작 과정

1. 새로 생성된 객체가 Eden 영역에 할당된다.
2. 객체가 계속 생성되어 Eden 영역이 꽉 차게 되고 Minor GC가 실행된다.
    - Eden 영역에서 사용되지 않는 객체의 메모리가 해제된다.
    - Eden 영역에서 살아남은 객체는 1개의 Survivor 영역으로 이동된다.
3. 1~2번의 과정이 반복되다가 Survivor 영역이 가득 차게 되면 Survivor 영역의 살아남은 객체를 다른 Survivor 영역으로 이동시킨다.
    - 1개의 Survivor 영역은 반드시 빈 상태가 된다.
4. 이러한 과정을 반복하여 계속해서 살아남은 객체는 Old 영역으로 이동(Promotion)된다.

![Minor GC](https://velog.velcdn.com/images/yarogono/post/cb487aa7-f760-4af4-b13a-949f628aa426/image.png)

여기서 객체의 생존 횟수를 카운트하기 위해 Minor GC에서 객체가 살아남은 횟수를 의미하는 Age를 Object Header에 기록한다. Minor GC 때 Object Header에 기록된 age를 보고 **Promotion 여부를 결정**한다.

## Q8. 가비지 컬렉션의 두 종류의 차이점
![Garbage Collection](https://camo.githubusercontent.com/7575052d13f3ea2f3587b5f3ef1f557bc69e760a7d1318e1c42997344d48007a/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f72793226666e616d653d6874747073253341253246253246626c6f672e6b616b616f63646e2e6e6574253246646e253246644d34777166253246627471555773326c57384825324647765245436d735549665a326a68446f4b6853434430253246696d672e706e67)

Young 영역은 일반적으로 Old 영역보다 크기가 작기 때문에 GC가 보통 0.5초에서 1초 사이에 끝난다. 그렇기 때문에 Minor GC는 애플리케이션에 크게 영향을 주지 않는다. 하지만 Old 영역은 Young 영역보다 크며 Young 영역을 참조할 수도 있다. 그렇기 때문에 Major GC는 일반적으로 Minor GC보다 시간이 오래 걸리며, 10배 이상의 시간을 사용한다.

## Q9. JVM의 메모리 구조
- **Method Area(메소드 영역):** 클래스 변수의 이름, 타입, 접근 제어자 등과 같은 클래스와 관련된 정보를 저장한다. 그 외에도 static 변수, 인터페이스 등이 저장된다.
- **Heap Area(힙 영역):** new를 통해 생성된 객체와 배열의 인스턴스를 저장하는 곳이다. 가비지 컬렉터는 힙 영역을 청소하며 메모리를 확보한다.
- **Stack Area(스택 영역):** 메소드가 실행되면 스택 영역에 메소드에 대한 영역이 1개 생긴다. 이 영역에 지역변수, 매개변수, 리턴값 등이 저장된다.
- **PC register(PC 레지스터):** 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장한다. (CPU의 레지스터와 다르다.)
- **Native Method Stack(네이티브 메소드 스택):** 자바 외의 언어(C, C++ 등)로 작성된 코드를 위한 메모리 영역이다. JNI를 통해 사용된다.

## Q10. String 특징과 저장 위치
- 문자열을 저장하는 자료구조
- 불변이라는 특성을 가짐
- 객체의 값이 업데이트가 되는 것이 아닌 업데이트된 객체를 만들고 그 곳을 참조함.
- 저장위치
  - **Heap:** new하면 Heap 영역에 생성
  - **String Constant Pool:** String Constant Pool은 힙의 일부 영역으로써, "ABC"이라는 문자열 리터럴이 프로그램 내에서 여러 번 사용되더라도, 서로 다른 메모리 위치에 저장되지 않고 String Constant Pool의 같은 메모리 주소를 참조한다. 그 후 스택에는 스트링의 참조값만 저장됨.

## Q11. StringBuilder와 StringBuffer의 차이점은 무엇인가요?
- **StringBuffer:** 동기화를 지원한다. 스레드에 안전하지만 성능이 늦다. 자주 조작되고, 멀티스레드 환경에서 좋다.
- **StringBuilder:** 단일 스레드 환경에서 빠른 문자열 조작이 필요하다. 동기화를 지원하지 않는다.

## Q12. StringBuilder, StringBuffer가 언제 OutOfMemoryError가 발생할까요?
확장된 내부 배열의 크기가 JVM 힙 메모리를 초과하면 OutOfMemoryError가 발생합니다.
