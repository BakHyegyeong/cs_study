# 객체 지향이란?

![객체 지향 이미지](https://blog.kakaocdn.net/dn/cVOt8q/btrwtAoYpWE/NDKkFh2kV3StqWpgGm9bF1/img.png)

- 프로그래밍에서 필요한 데이터를 추상화하여 상태와 행위를 가진 객체로 만들고, 객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.
- 코드 재사용성과 유지보수가 용이하지만, 객체 지향 언어는 상대적으로 느리고 메모리를 많이 사용할 수 있습니다.

### 객체
- 속성과 행위를 가진 것  
  **예시:** 객체: **꽃** -> 속성: 색깔, 향기, 키 -> 행위: 피어나다, 시들다

---

# 객체지향 프로그래밍의 특징 (4가지)

1. **캡슐화 (Encapsulation)**
    - 객체의 속성과 행위를 하나로 묶고, 외부에서 접근을 제한하는 것  
      (접근 제어자를 통해 외부에서 접근을 제한)
    - 정보를 보호할 수 있음  
      **예시:** 객체의 속성을 `private`으로 설정하고, 메서드(`get()`)를 통해 속성에 접근

2. **상속 (Inheritance)**
    - 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 사용하는 것
    - 코드 재사용성을 높임  
      **예시:** 부모 클래스로 동물을 두고 강아지와 고양이 클래스가 이를 상속받아 사용

3. **다형성 (Polymorphism)**
    - 하나의 메서드나 클래스가 다양하게 해석될 수 있음  
      **예시:**
        - 오버로딩: 같은 메서드명을 가지면서도 다른 역할을 수행하는 여러 메서드 가능
        - 오버라이딩: 상위 클래스와 하위 클래스가 동일한 메서드 이름으로 다른 동작을 수행

4. **추상화 (Abstraction)**
    - 공통된 속성이나 기능을 묶는 것
    - 코드 재사용성을 높임  
      **예시:** 강아지와 고양이를 `동물`이라는 클래스로 묶어서 공통된 부분을 구현

---

# 객체 지향 설계의 5대 원칙 (SOLID)

### 1. 단일 책임 원칙 (SRP)
- 클래스는 단 하나의 책임만 가져야 함
- 클래스의 응집도를 높이고, 변경이 용이해짐  
  **예시:** 청소기는 청소만 담당해야 함. 청소기가 빨래나 요리를 하면 안 됨.

**응집도**: 클래스가 하나의 목적을 위해 얼마나 밀접하게 관련된 기능들을 수행하는지를 나타냄.

---

### 2. 개방-폐쇄 원칙 (OCP)
- 확장에는 열려있고, 수정에는 닫혀있어야 함
- 기존 코드를 변경하지 않고 새로운 기능을 추가해야 함  
  **예시:** 상속 관계에서 상위 클래스를 수정하지 않고 하위 클래스를 추가하여 기능을 확장

---

### 3. 리스코프 치환 원칙 (LSP)
- 자식 클래스가 부모 클래스를 대체할 수 있어야 함

```java
public void myData() {
    // Collection 인터페이스 타입으로 변수 선언
    Collection data = new LinkedList();

    data = new HashSet(); // 중간에 전혀 다른 자료형 클래스를 할당해도 호환됨

    modify(data); // 메서드 실행
}

public void modify(Collection data) {
    data.add(1); // 인터페이스 구현 구조가 잘 잡혀있어서 호환됨
}
```

---

### 4. 인터페이스 분리 원칙 (ISP)
- 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않아야 함
- 클라이언트의 목적에 적합한 인터페이스만 제공해야 함  
  **예시:** 인터페이스를 여러 개로 나누어 사용하지 않는 메서드에 의존하지 않도록 구성

---

### 5. 의존성 역전 원칙 (DIP)

![의존성 역전 이미지](https://velog.velcdn.com/images/harinnnnn/post/5217fd08-c236-414a-812f-1b5977cda612/image.png)

- 고수준 모듈은 저수준 모듈에 의존하면 안 됨
- 의존 관계를 맺을 때 쉽게 변화하는 것보다, 변화가 어려운 것에 의존해야 함  
  **예시:** 인터페이스나 추상클래스의 구현체에 의존하지 않고, 해당 인터페이스나 추상클래스에 의존

**고수준 모듈**: 의미 있는 단일 기능을 제공하는 모듈 (interface, 추상 클래스)  
**저수준 모듈**: 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현 (메인클래스, 객체)

---
