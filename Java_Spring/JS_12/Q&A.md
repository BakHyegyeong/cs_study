## Q1. IoC를 사용하면 장점이 무엇인가요?

- **결합도 감소**: 객체 간의 결합도가 낮아져 유지보수성과 유연성이 높아짐.
- **객체 관리**: 객체의 생명주기를 IoC 컨테이너(SPRING)가 관리하므로, 개발자가 객체 관리에 대해 걱정할 필요가 없음.

---

## Q2. DI란 무엇인가요?

- **의존성 주입 (Dependency Injection)**:
    - 객체가 다른 객체를 필요로 할 때, 의존 객체를 직접 생성하지 않고 외부에서 주입받는 방식.
    - Spring이 Bean을 생성하고, 의존성을 주입함.
    - 주입 방식: **생성자 주입**, **Setter 주입**, **필드 주입** 등.

---

## Q3. DI 방식 중 가장 권장되는 방식은?

- **생성자 주입**:
    - 의존성을 생성자를 통해 주입받아 **불변성**을 보장.
    - **장점**:
        - Lombok을 사용하여 간결한 코드 작성 가능.
        - 의존성이 명확하게 드러남.
        - 테스트가 용이함.
    - **Setter 주입**:
        - 선택적 의존성을 처리할 때 유용.
        - 하지만 의존성이 누락된 상태에서 객체가 사용될 위험이 있어 일반적으로 권장되지 않음.
    - **필드 주입** (`@Autowired`):
        - 테스트가 어렵고 의존성이 숨겨져 명시적이지 않아 사용을 지양.

---

## Q4. IoC와 DI의 관계

- IoC 컨테이너가 DI를 통해 객체 간 의존성을 관리하며, 이 과정에서 **제어의 역전(Inversion of Control)**이 발생.

---

## Q5. Spring IoC Container의 역할

- **객체 관리**:
    - 객체를 생성, 의존성 주입, 결합 및 생명주기 관리.
- **DI 지원**:
    - 어플리케이션 구성 요소의 의존성을 자동으로 연결.
- **구성 정보 사용**:
    - XML, Java 코드, 어노테이션, POJO 클래스를 사용하여 객체 정보를 가져옴.
    - IoC 컨테이너가 생성한 객체를 **Bean**이라고 부름.

---

## Q6. IoC Container의 단점

- **시작 시간 증가**: 시스템 초기화 시 시간이 더 걸림.
- **실행 중 오버헤드**: 런타임 시 추가적인 처리로 성능 저하 가능.

---

## Q7. IoC란?

- **Inversion of Control (제어의 역전)**:
    - 객체 생명주기 및 관리를 개발자가 아닌 IoC 컨테이너(SPRING)가 관리.
    - 객체에 대한 제어권이 개발자에서 스프링으로 넘어감.

---

## Q8. ApplicationContext란?

- **Spring IoC 컨테이너 인터페이스**:
    - 애플리케이션 실행 시 XML 파일 또는 Java 설정 정보를 기반으로 Bean 객체를 관리하고 주입.
- **역할**:
    - IoC 컨테이너의 구현체로, 애플리케이션의 Bean을 관리.

---

## Q9. DI 구현 방법

1. **생성자 주입**
    - 의존성을 생성자에서 주입.
2. **Setter 주입**
    - Setter 메서드를 통해 의존성을 주입.
3. **필드 주입**
    - `@Autowired`를 사용하여 의존성을 필드에 주입.
