# 디자인 패턴 면접 질문 정리

## Q1. 디자인 패턴이란?
- **정의**: 개발 중 반복적으로 발생하는 문제에 대한 검증된 해결 방안.
- **효과**:
    - 안정성을 높이고 유지보수성을 향상시킴.
    - 가독성과 재사용성을 증가시킴.

---

## Q2. GoF 패턴을 간략하게 말해주세요.
GoF 패턴은 23개의 디자인 패턴으로 구성되며, 세 가지 유형으로 분류됩니다.

### 1. 생성(Creational) 패턴
- **팩토리 메서드 (Factory Method)**: 객체 생성 인터페이스를 정의하고, 하위 클래스가 인스턴스를 결정.
- **추상 팩토리 (Abstract Factory)**: 관련된 객체 집합을 생성하는 인터페이스 제공.
- **빌더 (Builder)**: 복잡한 객체의 생성 과정을 단계적으로 처리.
- **프로토타입 (Prototype)**: 기존 객체를 복사해 새로운 객체 생성.
- **싱글톤 (Singleton)**: 클래스의 인스턴스를 하나로 제한.

### 2. 구조(Structural) 패턴
- **어댑터 (Adapter)**: 인터페이스 변환을 통해 호환성 제공.
- **브리지 (Bridge)**: 구현과 추상을 분리하여 독립적으로 확장 가능.
- **컴포지트 (Composite)**: 객체를 트리 구조로 구성해 전체-부분 관계 표현.
- **데코레이터 (Decorator)**: 동적으로 객체에 새로운 기능을 추가.
- **퍼사드 (Facade)**: 서브시스템의 복잡성을 숨기고 단순화된 인터페이스 제공.
- **플라이웨이트 (Flyweight)**: 공유를 통해 메모리 사용량 감소.
- **프록시 (Proxy)**: 접근 제어 또는 부가 기능을 위해 대리 객체 사용.

### 3. 행위(Behavioral) 패턴
- **인터프리터 (Interpreter)**: 언어의 문법 표현 및 해석.
- **템플릿 메서드 (Template Method)**: 공통 구조를 정의하고 세부 처리는 서브클래스에서 구현.
- **책임 연쇄 (Chain of Responsibility)**: 요청을 처리할 객체를 연결해 처리 책임 위임.
- **커맨드 (Command)**: 요청을 객체로 캡슐화해 재사용 가능성 증대.
- **이터레이터 (Iterator)**: 컬렉션 요소 순회 인터페이스 제공.
- **미디에이터 (Mediator)**: 객체 간 복잡한 상호작용을 중재.
- **메멘토 (Memento)**: 객체 상태를 캡슐화하여 복원 가능.
- **옵저버 (Observer)**: 객체 상태 변화를 관찰하고 알림.
- **전략 (Strategy)**: 행위를 캡슐화하여 동적으로 변경.
- **비지터 (Visitor)**: 객체 구조를 수정하지 않고 새로운 연산 추가.

---

## Q3. Observer 패턴이란 무엇인가요?
- **정의**: 객체 상태 변화를 관찰하고, 이벤트가 발생하면 이를 옵저버(Listener)들에게 알림.
- **특징**:
    - 하나의 객체(Subject) 상태 변화 시, 여러 옵저버가 자동으로 업데이트.
- **장점**:
    - 느슨한 결합으로 유지보수성과 코드 재사용성이 높음.
- **단점**:
    - 옵저버 수가 많거나 복잡한 알림 전달 시 성능 저하 가능.

---

## Q4. 싱글톤 패턴이란?
- **정의**: 클래스 인스턴스를 단 하나만 생성하고 전역적으로 접근할 수 있도록 보장.
- **사용 사례**: 공통 객체 생성(예: 데이터베이스 연결, 로깅).
- **장점**:
    - 메모리 낭비 방지.
    - 전역 접근성을 통해 객체 상태 공유 가능.
- **단점**:
    - 개방 폐쇄 원칙 위배 가능.
      - 인스턴스를 하나만 생성하도록 제한하므로 클래스를 확장(상속)하거나 수정이 어려움.
    - 멀티스레드 환경에서 동기화 문제 발생 가능.
      - 해결 방안 1: `synchronized` 키워드 사용.
      - 해결 방안 2: 미리 인스턴스 생성 후 반환.
      - 해결 방안 3: `volatile` 키워드 사용.
    - 단위 테스트 시 객체 상태에 따라 문제 발생 가능.

---

## Q5. 템플릿 메서드 패턴이란?
- **정의**: 작업 처리의 공통 구조는 유지하되, 특정 단계 구현은 서브클래스에서 처리.
- **장점**:
    - 코드 중복 감소.
    - 상속을 통해 확장 가능.

---

## Q6. 프록시 패턴의 예시
- **정의**: 접근 제어나 부가 기능을 위해 대리 객체를 사용하는 패턴.
- **예시**:
    - **프록시 서버**: 클라이언트가 다른 네트워크 서비스에 간접적으로 접근할 수 있도록 지원.

---

## Q7. 전략 패턴과 커맨드 패턴의 차이점
- **전략 패턴**: 행위를 클래스로 캡슐화해 동적으로 행위를 변경 가능.
- **커맨드 패턴**: 실행될 기능을 캡슐화해 여러 기능을 재사용 가능하도록 설계.

---

## Q8. 디자인 패턴의 문제점
- **오버 엔지니어링**:
    - 패턴 남용으로 코드 복잡도 증가 가능.
- **적합하지 않은 상황에서 사용**:
    - 특정 문제에 적합하지 않은 패턴 사용 시 오히려 문제를 복잡하게 만듦.

---

## Q9. 팩토리 메서드란?
- **정의**: 객체 생성을 위한 인터페이스를 제공하며, 구체적인 생성 로직은 하위 클래스에서 결정.
- **장점**: 객체 생성 코드를 변경하지 않고 확장 가능.

---

## Q10. 빌더 패턴이란?
- **정의**: 복잡한 객체 생성 과정을 단순화하고 단계별로 객체를 구성.
- **장점**:
    - 객체 생성 로직을 분리하여 코드 가독성 향상.
    - 동일한 객체 생성을 위한 다양한 표현 가능.
