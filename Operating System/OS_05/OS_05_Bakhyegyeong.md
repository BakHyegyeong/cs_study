## 메모리 계층 구조

: 메모리 계층의 구조는 레지스터, 캐시, 메모리, 저장장치로 구성되어 있다.

→ 메모리가 계층이 나뉘어져 있는 이유는 <u>CPU가 메모리에 더 빨리 접근</u>하기 위함이다.

- **레지스터** : CPU안에 있는 작은 메모리
- **캐시** : L1, L2 캐시를 지칭
- **주기억장치** : RAM
→ 하드디스크, 인터넷으로부터 **일정량의 데이터를 복사해 임시로 저장**하고 이를 **CPU에 빠르게 전달**하는 역할
- **보조기억장치** : HDD, SSD
    
    → 하드디스크에 CPU가 직접 접근할 수 없으므로 **하드 디스크의 데이터를 메모리로 이동시키고 메모리에서 접근**한다.
    

![image.png](https://velog.velcdn.com/images/ajm0718/post/0036956a-d786-449e-94e9-959c9efa73a4/image.png)

| / | 휘발성 | 속도 | 기억 용량 |
| --- | --- | --- | --- |
| 레지스터 | 빠름 | 빠름 | 작음 |
| 캐시 | 빠름 | 빠름 | 작음 |
| 주기억장치 | 보통 | 보통 | 보통 |
| 보조기억장치 | 비휘발성 | 낮음 | 많음 |

<br>

---

## 캐시와 버퍼의 차이점

### 캐시

: **데이터를 미리 복사해 놓는 임시 저장소**이자 지역성을 기반으로 자주 사용되는 데이터를 찾은 후 이를 기반으로 설정한다. 

- 캐싱 계층
    - **주기억장치** : 캐시 메모리와 보조기억장치 사이에 있는 캐싱 계층
    - **레지스터** 계층 : 메모리와 CPU 사이에 존재하는 캐싱 계층
- 웹 브라우저 : 쿠키, 로컬 스토리지, 세션 스토리지

### 버퍼

: 데이터를 한 곳에서 다른 곳으로 **전송하는 동안 일시적으로 그 데이터를 보관**하는 메모리 영역이다.

- 버퍼링 : 영상의 시청 속도와 내려받는 속도 차이 때문에 영상이 멈출 때를 대비하여 버퍼에 미리 영상을 내려받는다.
- java의 BufferedWriter는 입력된 값을 바로 출력하지 않고 저장해두었다가 한번에 출력한다.

### 캐시와 버퍼의 공통점과 차이점

- **공통점** : 속도에 차이가 있는 두 장치 사이에서 그 차이를 완화
    
    → 빠른 장치와 느린 장치에서 **속도 차이에 따른 병목 현상을 줄이기 위한 메모리**이다.
    
- **차이점**
    - **휘발성**
        - 캐시 : 캐시메모리에 저장된 데이터를 계속해서 사용 가능
        - 버퍼 : 전송 후 데이터를 다시 사용할 수 없다.
    - **목적**
        - 캐시 : **작업의 속도를 증진**시키고자 하는 목적
        - 버퍼 : **데이터의 손실을 방지**하고자 하는 목적


---

## 프로세스와 스레드의 차이점

- 프로세스 : 실행되고 있는 프로그램이자 **프로그램이 메모리에 올라가 인스턴스화 된 것** <br>
→ CPU 스케쥴링의 대상이 되는 작업
- 스레드 : 프로세스가 할당받은 자원을 이용하는 **프로세스** 내 작업의 흐름

### 차이점

1. 메모리 공유 방식
    - 프로세스 : 운영체제는 프로세스마다 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당해준다.
        
        → 프로세스는 다른 프로세스의 변수나 자료에 접근할 수 없다.
        
        → 접근하고자 한다면 IPC를 사용하는 등의 번거로운 과정을 거쳐야 한다.
        
    - 스레드 : 프로세스가 할당받은 메모리 영역 내에서 stack영역은 따로 할당받고 나머지 Code, Data, Heap영역은 공유한다.
        
        → 스레드끼리는 힙 메모리를 서로 읽고 쓸 수 있다.
        
    
2. 멀티 태스킹과 멀티 스레드 
    
    : **멀티태스킹**이 하나의 운영 체제 안에서 여러 프로세스가 실행되는 것이라면, **멀티스레드**는 하나의 프로세스가 여러 작업을 여러 스레드를 사용하여 동시에 처리하는 것을 의미한다.
    

1. PCB와 TCB
    - PCB (Process Control Block) : 프로세스에 대한 메타데이터를 저장한 데이터
        
        → CPU는 프로세스의 상태에 따라서 Context Switching이 이루어지는데 이때 **교체되는 프로세스의 상태 값을 PCB에 저장**해두었다가 나중에 다시 프로세스를 실행할 때 사용한다.
        
    - TCB (Thread Control Block) : 스레드를 관리하는 자료구조
        
        → PCB내에 포함되어 있으며 PCB보다 저장하는 정보가 적고 공유하는 자원이 존재한다.
        
        → 스레드간의 Context Switching은 Stack만 교환해도 된다.
        
        ![image.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FuA6y7%2FbtrHdwLqcK5%2F347r3swojezn5HTIae4sA0%2Fimg.png)
        
        : 프로그램 계수기(프로세스가 다음에 실행할 명령어의 주소)와 같은 CPU 관련 정보가 TCB에 저장된다.
        
        → 스레드가 하나 생성될 때마다 PCB내에서 TCB가 확장된다.
        
        ![image.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fpouij%2FbtrHaUySUkZ%2F22UlS0GsFh6QBaRKgcGUTk%2Fimg.png)
        
2. 라이프 사이클

![image.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcw5mGd%2FbtsB7UXtPrX%2Fh4J35JNtRXUWv2c7p5tKmK%2Fimg.png)

- 프로세스 : create , ready , running , **waiting/blocked** , terminated
- 스레드 : new , **runnable** , running , **blocked** , **waiting** , **timed_waiting** terminated

- blocked : IO입출력이나 이벤트가 발생했을 때
    - 프로세스 : IO입출력이나 이벤트가 완료될 때까지 대기
    - 스레드 : 같은 자원에 접근하는 스레드들에 의해 사용하고자 하는 객체에 걸린 lock이 풀릴 때까지 대기
- waiting
    - 프로세스 : blocked와 동일
    - 스레드 : 다른 스레드를 기다리는 것,  timed_waiting은 지정된 기간 동안 기다리는 것

### 프로세스와 스레드의 예시
- 프로세스 : 크롬창을 여러개 띄운 것
- 스레드 : 크롬 내에서 탭을 여러개 띄운 것 <br>
   → 크롬의 캐시 등을 공유하기 때문에 탭1에서 로드된 이미지는 탭2에서 바로 로딩될 수 있다
