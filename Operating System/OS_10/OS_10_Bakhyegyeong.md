# IPC(**Inter Process Communication**)

: 커널에서 제공되는 **프로세스들끼리 서로 데이터를 주고받는 행위 또는 그에 대한 방법**을 뜻한다.

### IPC가 필요한 이유

: 프로세스는 **정보 공유와 계산 속도 향상** 등의 이유로 다른 프로세스와 통신을 해야 하지만 **프로세스는 독립된 메모리 공간에서 실행**되므로 다른 프로세스와 정보를 공유하기 위해서 IPC를 사용한다. 

1. **정보 공유** : 여러 프로세스가 동일한 정보에 관심을 둘 수 있으므로 이를 공유한다.
2. **계산 속도 향상** : 하나의 일을 여러 프로세스가 수행하도록 나눈 후 멀티코어를 활용하여 병렬로 계산한다.
3. **모듈성** : 시스템 기능을 별도의 프로세스로 분리한다.
4. **편의성** : 사용자들이 한 번에 여러 작업을 할 수 있게 구성한다.

<br><br>


# IPC의 종류

## **1. 메시지 전달 (Message Passing)**

: 커널 메모리 영역을 통해 프로세스들 사이에 메시지 형태로 정보를 Send/Receive 하는 방법

- 직접 통신 (Direct Communication) : 데이터를 누구에게 보낼지 그리고 누구에게 받을지 명시하는 통신 방법
    
    → **두 프로세스** 사이에 단 하나의 회선이 자동으로 구축된다.
    
- 간접 통신 (Indirect Communication) : 우편함(mailbox)이라는 간접적인 매체를 통해 메시지를 전송하는 통신 바법
    
    → **각 우편함은 고유한 id**를 가지고 있어 프로세스가 어떤 메일함을 사용할 것인지 선택할 수 있고 **세 개 이상의 프로세스도 데이터를 공유**할 수 있다.
    
![](https://milktea24.github.io/assets/img/posts/cs/os/ipc/message-passing.png)

### 예시

- 파이프 : 두 프로세스 사이의 통신을 구현한다.
    - Ordinary Pipes : 생산자는 데이터를 쓸 수만 있고 소비자는 데이터를 읽을 수만 있어 **단방향 구조**를 가진다.
    - Named Pipes : 통신하기 위해 부모-자식 관계가 필요 없어 여러 프로세스가 사용 가능하며 **양방향 구조**이다.
- 메시지 큐 (Message Queue) : 송신 프로세스는 큐에 enqueue, 수신 프로세스는 큐에 dequeue하며 통신한다.
- 소켓 (TCP/IP) : 로컬에서도 통신이 가능하며 원격에서도 다른 컴퓨터의 프로레스와 통신이 가능하다.

## **2. 공유 메모리 (Shared Memory)**

: 프로세스끼리 **특정 공통의 메모리 영역을 공유**하며 상호 통신하는 방법이다.

**데이터 자체를 공유**하도록 지원하며, 한 프로세스에서 변경한 메모리 공간의 내용을 다른 프로세스에서 접근할 수 있다.

![](https://milktea24.github.io/assets/img/posts/cs/os/ipc/shared-memory.png)

## 메시지 전달과 공유 메모리 방식의 차이점

### 1. 성능

- 메시지 전달 : **하나의 메시지마다 두 번의 시스템 콜을 호출**한다. 메시지를 커널에 전송할 때와 메시지를 받아갈 때 각각 두번 데이터를 복사한다.
    
    → 즉 **메시지의 수가 많아지는 경우 오버헤드가 발생**하지만 공유 메모리보다 처음 setup시 발생하는 오버헤드가 적다.
    
- 공유 메모리 : 처음 setup할 때 오버헤드가 크지만 메모리가 할당된 이후 데이터의 크기에 따른 패널티가 거의 없다.
    
    → **데이터의 크기가 큰 경우 메시지 전달 방식보다 유리**하다.
    

### 2. 동기 문제

- 메시지 전달 : send/receive 방식을 사용해 비교적 간단하게 동기 문제를 해결할 수 있다.
- 공유 메모리 : 두 프로세스가 동시에 쓰기 작업을 시도할 경우 별도의 처리 과정이 필요하다.
    
    → 프로세스 간 데이터를 동기화하고 보호하기 위해 <span style="color:red">**세마포어(Semaphore)** 와 **뮤텍스(Mutex)**</span> 를 사용한다.
    

### 3. 커널 관여 여부

- 메시지 전달 : 프로세스가 메시지를 보내면 커널의 Message Queue에 전달된다. 이후 프로세스가 메시지를 받을 때 Message Queue에서 받는다.
- 공유 메모리 : 처음 공유 메모리 할당에만 관여하고 이후 두 프로세스가 할당된 공유 메모리를 바탕으로 정보를 교환한다.

<br><br>

---

# Mutex와 Semaphore 차이점

뮤텍스와 세마포어 모두 데이터를 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 도구이다.


## Mutex 뮤텍스

: 임계 영역을 가진 스레드들의 실행시간이 서로 겹치지 않고 단독으로 실행, 상호배제할 수 있게 하는 기술

→ 스레드가 lock()을 통해 잠금 설정하고 사용 후 unlock()을 통해 잠금 해제하는 객체이다.

한 프로세스에 의해 소유될 수 있는 Key를 기반으로 하며 이 **key를 소유한 스레드/프로세스만이 공유자원에 접근**할 수 있도록 하며 **다른 접근은 동기화 또는 락을 사용**해 막는다.

![image.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcvk7nh%2FbtrjvSw2BoX%2FZfh0o0VsZrMmAOi6PxLvg0%2Fimg.png)

## Semaphore 세마포어

: 멀티 프로그래밍 환경에서 공유된 자원에 대한 접근을 제한하는 방법

→ wait(), Signal() 함수를 통해 세마포어가 프로세스를 대기시키고 순서를 넘겨준다.

사용하고 있는 스레드/프로세스의 수를 공통으로 관리하는 하나의 값을 이용해 관리한다. 공유 자원에 접근할 수 있는 프로세스의 최대 허용치만큼 사용자가 동시에 접근할 수 있게 하며 각 프로세스는 세마포어의 값을 확인하고 변경할 수 있다.

![image.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcYZOiu%2FbtrjvrzaimS%2FQtooHYav5Sj1JpT9yTtb1K%2Fimg.png)

## 차이점

1. **동기화 대상의 갯수** : Mutex는 동기화 대상이 1개일 때, Semaphore는 동기화 대상이 1개 이상일 때 사용한다.
2. **전환 여부** : 세마포어는 뮤텍스가 될 수 없지만 Mutex는 세마포어가 될 수 없다.
→ Mutex는 0,1의 상태만 존재하는 이진 상태를 가지므로 Binary Semaphore라 할 수 있다. 
→ 하지만 뮤텍스는 잠금을 기반으로 하는 잠금 메커니즘이지만 세마포어는 신호를 기반으로 하는 신호 메커니즘이다.
3. **자원 소유** : Mutex는 자원을 소유할 수 있지만 Semaphore는 자원의 소유가 불가능하다.
4. **해제 여부** : 소유하고 있는 스레드만이 이 Mutex를 해제할 수 있다. Semaphore의 경우에는 Semaphore를 보유하지 않는 스레드도 이 Semaphore를 해제할 수 있다.

## 뮤텍스와 세마포어의 문제점
- 뮤텍스 : 공유 자원이 1개이다보니, 프로세스가 뮤텍스를 해제하지 않으면 해제되기까지 계속 기다리는 기아 현상(starvation)은 발생 가능
- 세마포어 : 다른 프로세스가 점유하고 있는 공유 자원을 계속  바라보고만 있는 데드락에 빠질 수 있다.