## 메모리 단편화

: RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 **사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능**한 상태

### 내부 단편화

: 메모리를 할당할 때 **프로세스가 필요한 양보다 더 큰 메모리가 할당**되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 상황

![](https://velog.velcdn.com/images/hanhs4544/post/91bfb9bd-2bcd-4ebc-821f-3886c1d998a3/image.png)

### 외부 단편화

: 메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 생기게 되고 이 과정이 반복되면서 사용하지 않는 메모리가 많아져 **총 메모리 공간은 충분하지만 실제로 할당이 불가능**한 상황

![](https://velog.velcdn.com/images/hanhs4544/post/3b75824b-d361-411b-b087-de58f6d2e221/image.png)

## 메모리 단편화 문제 해결 방법

### 페이징 기법 (Paging)

<span style="background-color:#fff5b1">
- 가상메모리 사용, 외부 단편화 해결, 내부 단편화 존재

: 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 방법

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbgDg92%2Fbtr8kJvNDT0%2FkMy3hvcJSU4Vtdkw3KOTu0%2Fimg.png)

- 프레임과 페이지를 대응시키기 위한 page mapping 과정이 필요해 paging table이 존재한다.

<br>

- **연속적이지 않은 공간도 활용할 수 있기에 외부 단편화 문제를 해결**할 수 있다.
- 프로세스가 **할당된 페이지 단위에 맞춰 메모리를 꽉 채워 쓸 수 없으므로 내부 단편화 문제는 여전히 존재**한다.

<br>

> 💡 **페이지** : **보조기억장치를 이용한 가상메모리(논리 주소)** 를 같은 크기의 블록으로 나눈 것 <br>
→ **가상 메모리**를 사용하는 최소 크기 단위이자 주소를 표기 <br><br>
**프레임** : **주기억장치(RAM, 물리 주소)** 를 페이지와 같은 크기로 나눈 것 <br>
→ **실제 메모리**를 사용하는 최소 크기 단위이자 주소를 표기

</aside>

### 세그멘테이션 (Segmentation)

<span style="background-color:#fff5b1">
- 가상 메모리 사용, 외부 단편화 존재, 내부 단편화 해결

: **가상 메모리를** **서로 크기가 다른 논리적 단위인 세그먼트**로 분할해 메모리를 할당하고 **실제 메모리 주소로 변환**하는 방법

![](https://velog.velcdn.com/images/hanhs4544/post/2104f437-1c2a-4c60-945f-5803db6ce396/image.png)

- 세그먼트는 연속적인 공간에 저장되어 있다.
- 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈 공간을 찾아서 할당된다.
- mapping을 위한 segment table이 존재한다. 이 table에는 각 **세그먼트 항목별로 세그먼트 시작 주소와 길이 정보**가 저장된다.

<br>


- **프로세스가 요구하는 메모리 크기에 맞게 할당**하기 때문에 **내부 단편화 문제를 해결**한다.
- 중간에 프로세스가 메모리를 해제하면 생기는 **작은 메모리에 의한 외부 단편화 문제는 존재**한다.

### 메모리 풀

<span style="background-color:#fff5b1">
- 외부 단편화 해결, 내부 단편화 해결

: **필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당**받아 놓고 필요할 때마다 사용하고 반납하는 방법

- **미리 공간을 할당하고 사용, 반납**하기 때문에 할당과 해제로 인한 외부 단편화 문제를 해결한다.
- **필요한 크기만큼 할당**하기 때문에 내부 단편화 문제도 해결된다.
- 메모리 풀을 만들었지만 사용하지 않았을 때 메모리 낭비가 심하므로 **잦은 메모리 할당, 해제 상황에서 효과적**이다.