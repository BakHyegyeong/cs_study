## Q1. 이진 탐색 트리의 정의와 특징과 장단점

- **정의:**
    - 이진 탐색(binary search)의 효율적인 탐색 방식을 사용하면서, 연결 리스트(linked list)로 삽입, 삭제, 탐색을 용이하게 만든 자료 구조
    - 노드의 왼쪽 하위 트리에는 노드의 키보다 작은 키가 있는 노드만 포함됩니다.
    - 노드의 오른쪽 하위 트리에는 노드의 키보다 큰 키가 있는 노드만 포함됩니다..
    - 왼쪽 및 오른쪽 하위 트리도 각각 이진 검색 트리여야 합니다.
    - 중복된 키를 허용하지 않습니다.

- **장점:**
    - 삽입, 삭제가 유연하다. (삭제된 노드를 가리키고 있던 reference만 조정해주면 된다.)
    - 값의 크기에 따라 좌/우 서브트리가 나눠지기 때문에 삽입, 삭제, 검색이 일반적으로 빠르다 (O(logN)).
    - 값의 순서대로 순회가 가능하다.

- **단점:**
    - 보통 요소를 찾을 때 이진 탐색 트리의 경우 O(logn)이 소모되지만 최악의 경우 선형적 트리, 리스트가 되면서 O(n)이 소모된다.

## Q2. 이진 탐색 트리의 생성

- 예시: 50, 15, 62, 80, 7, 54, 11이 있을 때 삽입이 어떻게 이루어지는지 대략적으로 설명
    - 50을 트리의 루트 노드에 삽입한 후 다음 요소가 50보다 크다면 오른쪽으로, 작다면 왼쪽으로 삽입하는 과정을 반복한다.

## Q3. 다음과 같은 전위순회 코드가 있다. 중위 순회, 후위 순회 코드로 바꾼다면?
- **전위 순회 코드:**
```java
public void preOrder(Node node) {
    if(node != null) {
        System.out.print(node.data + " ");
        if(node.left != null) preOrder(node.left);
        if(node.right != null) preOrder(node.right);
    }
}
```

### System.out.print(node.data + " "); 의 순서를 바꾸면 된다.


- **중위 순회 코드:**
```java
public void inOrder(Node node) {
    if(node != null) {
        if(node.left != null) inOrder(node.left);
        System.out.print(node.data + " ");
        if(node.right != null) inOrder(node.right);
    }
}
```
- **후위 순회 코드:**
```java
public void postOrder(Node node) {
    if(node != null) {
        if(node.left != null) postOrder(node.left);
        if(node.right != null) postOrder(node.right);
        System.out.print(node.data + " ");
    }
}
```
## Q4. 중위 순회

<img src="https://www.jiwon.me/content/images/size/w1000/2021/11/inorder.png" width="70%">

## Q5. Heap은 우선순위 큐 구현에 어떻게 활용되나요?
- 우선순위 큐는 배열이나 연결리스트를 사용하면 삽입 시 O(n)
- 힙을 사용하면 O(logn)이 소모되며, 루트(최댓값/최솟값)를 제거하고 출력함으로써 우선순위 큐를 구현할 수 있다.

## Q6. 트리 순회의 방식과 각각의 사용 사례는 무엇인가요?
1. **전위 순회 (Pre-order):** 루트 -> 왼쪽 -> 오른쪽
    - 사용 사례: 트리 복사

2. **중위 순회 (In-order):** 왼쪽 -> 루트 -> 오른쪽
    - 사용 사례: 오름차순이나 내림차순 출력

3. **후위 순회 (Post-order):** 왼쪽 -> 오른쪽 -> 루트
    - 사용 사례: 트리 삭제

## Q7. 힙 삽입 삭제
- **삽입:** 새로운 노드를 마지막에 놓고 부모노드와 비교하면서 자리 선정
- **삭제:** 루트를 삭제하고 마지막 노드를 가져오고 자식 노드와 비교하며 자리 선정

## Q8. 트리 관련 O/X 문제
- 하나의 루트만 존재하는 것은 트리인가? **O**
  - 1개의 부모노래와 0개 이상의 자식 노드라고 되어있어서, 루트 노드만 존재해도 트리라고 함.
- A->B, B->C, C->A 이런 구조라면 이라면 트리라고 할 수 있나? **X**
    - 트리는 싸이클이 존재하면 안됨.
- 데이터를 순차적으로 저장하는지? 그리고 비선형인지? **X/O**
    - 트리는 순차적 저장하지 않는 비선형임.
- 트리의 높이에 따라 삭제, 삽입, 탐색 시간에 영향을 받는가? **O** 
    - 트리의 높이가 낮을수록 삽입, 삭제, 탐색 시간이 빠름.

## Q9. 인덱스를 사용해서 데이터를 탐색하는 트리로, 데이터베이스 인덱스로 사용되는 트리 종류는?
- **B+ 트리**
