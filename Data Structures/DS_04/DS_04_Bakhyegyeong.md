## 해시 테이블

: **Key, Value(데이터=컬럼의 값, 데이터의 위치)로 데이터를 저장하는 자료구조** 중 하나로 빠른 데이터 검색이 필요할 때 유용하다.

![](https://velog.velcdn.com/images/dlgosla/post/99256066-e70b-42b4-abb9-b4ab9f4c7b3b/image.png)

### 장점

- 데이터 삽입, 삭제, 조회가 빠르다.
    
    → 기본적으로 키 값으로 데이터를 찾으려면 해시 함수를 한 번만 실행하면 되기 때문이다.
    

### 단점

- 순서를 보장하지 않기 때문에, 순서, 관계가 있는 목적에는 적합하지 않다.
- 데이터가 pseudo-random 위치에 저장되기 때문에 데이터를 정렬된 순서로 접근할 때 비용이 높다.
- loop하면서 traverse하는 능력이 떨어진다.
    
    → 데이터가 산재된 확률이 높아 빈 버킷도 체크하면서 순회해야 하기 때문이다.
    
- 지역참조성에 취약하다.
    
    → 해시 테이블의 조회 자체가 버킷들을 건너뛰면서 확인하는 방식이기 때문이다. 
    
    그렇기에 프로세스가 계속해서 캐시 미스를 발생시키고 이는 오버헤드로 이어진다. 
    
    데이터가 적고 type이 간단한(Integer…) 경우에는 배열을 이용한 자료구조가 더 나은 성능을 보일 수 있다.
    
- 해시 테이블의 경우 **등호 연산(=)에만 특화되어있기 때문에 부등호 연산(>,<)이 자주 사용되는 데이터베이스 검색에서는 해시 테이블은 적합하지 않다.**

### 해시 테이블이 빠른 검색 속도를 제공하는 이유

해시 테이블은 내부적으로 **배열(버킷)을 사용하여 데이터를 저장**하기 때문에 빠른 검색 속도를 제공한다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb1zOw1%2FbtqL6HAW7jy%2FjpBA5pPkQFnfiZcPLakg00%2Fimg.png)

각각의 key값에 해시함수를 적용해 배열의 고유한 index를 생성하고 index를 활용해 값을 저장하거나 검색한다.

> 💡 버킷 / 슬롯 : 실제 값이 저장되는 장소
 


예를 들어 (Key, Value)가 ("John Smith", "521-1234")인 데이터를 크기가 16인 해시 테이블에 저장하고자 할 때

1. index = hash_function("John Smith") % 16 연산을 통해 **index 값을 계산**한다. 
2. array[index] = "521-1234" 로 전화번호(Value)를 저장한다.

이러한 해싱 구조로 데이터를 저장하면 **Key값으로 데이터를 찾을 때 해시 함수를 1번만 수행**하면 되므로 매우 빠르게 데이터를 저장/삭제/조회할 수 있다. **해시테이블의 평균 시간복잡도는 O(1)** 이다.

### 해시 함수(Hash 함수)

해시 함수에서 중요한 것은 고유한 인덱스 값을 설정하는 것이다.

해시 테이블에서 사용되는 대표적인 해시 함수로는 Division Method, Digit Folding, Multiplication Method, Univeral Hashing 이 있다.

1. Division Method: 나눗셈을 이용하는 방법으로 **입력값을 테이블의 크기로 나누어 계산**한다. 
    
    → 주소 = 입력값 % 테이블의 크기
    
    → 테이블의 크기를 소수나 2의 제곱수를 사용해야 효과가 좋다고 알려져 있다.
    
2. Digit Folding: 각 **Key의 문자열을 ASCII 코드**로 바꾸고 **값을 합한 데이터**를 테이블 내의 주소로 사용하는 방법이다.
3. Multiplication Method: **숫자로 된 Key값** **K**와 **0과 1사이의 실수 A**, **보통 2의 제곱수인 m**을 사용하여 다음과 같은 계산을 해준다. 
    
    → h(k)=(kAmod1) × m
    
4. Univeral Hashing: **다수의 해시함수를 만들어 집합 H**에 넣어두고, **무작위로 해시함수를 선택**해 해시값을 만드는 기법이다.

## 해시 충돌 (Hash Collision)

다른 키 값에 해시 함수를 돌렸는데 같은 해시 값이 나오는 경우

![](https://velog.velcdn.com/images/dlgosla/post/cdb800e9-6077-40cc-b1c2-0fd07c5dedc2/image.png)

### 해시 충돌 해결법 - 분리 연결법**(Separate Chaining)**

**동일한 버킷에 저장되어야하는 데이터에 체인**을 걸어 찾는 데이터가 나올 때까지 계속 체인을 따라가는 방식

**다른 자료구조(링크드 리스트, 트리)를 버킷에 연결**해서 다음 데이터를 저장한다.

![](https://velog.velcdn.com/images/dlgosla/post/c5fdcadc-6f0f-49de-82cd-a06bcc2ed3c7/image.png)

**장점**

- 버킷을 계속 사용해야하는 개방 주소법에 비해 **테이블의 확장을 늦출 수 있다.**
    
    → **확장은 O(m)** , (m은 key의 개수)의 시간복잡도를 요하기 때문에 꽤 치명적이다.
    

**단점**

- 데이터의 수가 많아지면 동일한 버킷에 chaining되는 데이터가 많아지며 그에 따라 **캐시의 효율성이 감소**한다.

### 해시 충돌 해결법 - 개방 주소법(**Open Addressing)**

저장해야하는 인덱스에 값이 있으면 **다른 인덱스에 저장하는 방법**

![](https://velog.velcdn.com/images/dlgosla/post/e8f788d3-9574-4939-8e75-510a1ed0cf4a/image.png)

**장점**

- 적은 양의 데이터에 효과적이다.
- 메모리 효율이 분리 연결법에 비해 좋다.
- 메모리 할당에 대한 오버헤드가 없다.
- 분리연결법에 비해 캐시 효율이 좋다.

**단점**

- 테이블의 확장이 필요할 수 있다.

**방법**

- 선형 탐사 : 계산된 해시 값에서 충돌이 발생하면 **고정폭만큼 건너 뛰면서 비어있는 인덱스에 저장**하는 방법
- 제곱 탐사 : **해시의 저장 순서 폭을 제곱**으로 저장하는 방식
    
    → 1만큼 건너뛰고, 다음 충돌이 발생하면 2^2, 3^2 으로 탐사를 진행한다.
    
- 이중 해싱 : **2차 해시 함수로 다시 해싱을 해서 새로운 주소를 할당**

## HashMap VS HashSet

- HashMap : **Map Interface의 구현체**로 HashTable과 유사한 자료구조로 데이터를 저장한다.
- HashSet : **Set Interface의 구현체**로, 내부적으로 HashMap을 사용해 데이터를 저장하기 때문에 HashTable과 유사한 자료구조로 데이터를 저장한다고 할 수 있다.

| 항목 | HashMap | HashSet |
| --- | --- | --- |
| 데이터 저장 형태 | key-value 형태로 데이터를 저장 | 객체 그 자체를 저장, dummy 객체를 value로 사용 |
| 데이터 삽입 방법 | `put()` 메서드를 사용해 데이터를 삽입 | `add()` 메서드를 사용해 데이터를 삽입 |
| 중복 허용 여부 | 중복 key는 허용하지 않지만, 중복 value는 허용 | 데이터 중복을 허용하지 않음 |
| null 허용 여부 | key로 단 하나의 null 값 가능, value는 여러 개 가능 | 단 하나의 null 값 가능 |
| 성능(속도) | HashSet보다 빠름 | HashMap보다 느림 |

## HashMap VS HashTable

: **동기화 지원 여부**

- HashMap : 동기화를 지원 X, 병렬 처리를 하지 않거나 자원의 동기화를 고려하지 않는 상황
- HashTable : 동기화를 지원 O, 병렬 처리를 하면서 자원의 동기화를 고려해야 하는 상황

```java
// HashMap의 put
public V put(K key, V value) {

// HashTable의 put
public synchronized V put(K key, V value) {
```