### Q1. 해시 테이블과 해시맵의 차이점은 무엇인가요?
- **Hashtable:**
    - 동기화가 되어 있어 멀티스레드 환경에서 안전하게 사용할 수 있지만, 성능이 떨어집니다.
- **HashMap:**
    - 동기화가 되어 있지 않아서 단일 스레드 환경에서 더 빠릅니다.

### Q2. 체이닝은 무엇인가?
- 해시 테이블에서 충돌이 발생하면 같은 해시값을 가진 데이터를 연결 리스트로 연결하는 방식입니다.

### Q3. HashMap과 HashSet은 순서를 유지하나요?
- **HashMap**과 **HashSet** 모두 기본적으로 순서를 유지하지 않습니다. 데이터의 순서와는 무관하게 해시 구조에 의해 데이터를 저장하고 접근하기 때문입니다.
- **LinkedHashMap**이나 **LinkedHashSet**을 사용하면 삽입된 순서대로 데이터를 저장하고, 순서대로 데이터를 검색할 수 있습니다.

### Q4. HashMap과 HashSet
- **HashMap:**
    - Key-Value 쌍으로 저장합니다. 
    - Key는 중복을 허용하지 않지만, Value는 중복을 허용합니다.
    - Key에 대한 정보를 저장할 때 사용합니다.
- **HashSet:**
    - HashMap 기반의 자료구조지만 단일 값만 저장할 수 있습니다. 
    - 중복값을 저장하지 못하며, null은 한 개만 허용합니다.
    - 중복으로 데이터를 저장하지 않아야 할 때 사용합니다.

### Q5. 해시 충돌을 해결하는 체이닝 외의 방법은?
- **개방 주소법:**
    - **선형 조사(Linear Probing):** 순차적으로 index를 증가시키며 빈 버킷을 찾아 저장합니다.
    - **이차 조사(Quadratic Probing):** 제곱수만큼 이동하며 빈 버킷을 찾습니다.
    - **이중 해싱(Double Hashing):** 두 번째 해시 함수를 이용하여 다음 빈 버킷을 찾습니다.

### Q6. HashMap의 키는 중복을 허용하지 않는데, 값은 왜 중복을 허용할까요?
- **HashMap**은 데이터의 고유 식별자이기 때문에 키는 중복이 허용되지 않습니다. 하지만 특정 키에 매핑된 값은 배열방에 입력된 데이터이기 때문에 중복해서 들어가도 상관없습니다.

### Q7. Hash Table의 장단점
- **장점:**
    - 해시함수를 이용해 키를 인덱스로 변환하기 때문에 데이터 삽입, 삭제, 조회가 O(1)의 시간복잡도를 가지면서 매우 빠릅니다.
- **단점:**
    - 해시 충돌 문제가 발생할 수 있습니다.
    - 순서를 보장하지 않기 때문에, 순서나 관계가 있는 목적에는 적합하지 않습니다.
    - 데이터가 pseudo-random(예측할 수 없는) 위치에 저장되기 때문에 데이터를 정렬된 순서로 접근할 때 비용이 높습니다.
    - 해시 테이블은 등호 연산(=)에만 특화되어 있어 부등호 연산(>,<)이 자주 사용되는 데이터베이스 검색에는 적합하지 않습니다.

### Q8. Hash 함수의 종류
- **Division Method:** 나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산합니다. → 주소 = 입력값 % 테이블의 크기
- **Digit Folding:** 각 키의 문자열을 ASCII 코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법입니다.
- **Multiplication Method:** 숫자로 된 키값 K와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같은 계산을 합니다. → h(k) = (kA mod 1) × m
- **Universal Hashing:** 다수의 해시함수를 만들어 집합 H에 넣어두고, 무작위로 해시함수를 선택해 해시값을 만드는 기법입니다.

### Q9. 해시 충돌 해결법인 분리 연결법의 장단점
- **장점:**
    - 버킷을 계속 사용해야 하는 개방 주소법에 비해 테이블의 확장을 늦출 수 있습니다.
- **단점:**
    - 데이터의 수가 많아지면 동일한 버킷에 체이닝되는 데이터가 많아지며 그에 따라 캐시의 효율성이 감소합니다.
    - 연결된 데이터의 개수가 많아지면 조회에 걸리는 시간 복잡도가 O(n)이 됩니다.
