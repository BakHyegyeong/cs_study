# Hash Table이 평균적으로 O(1) 성능을 유지하는 이유는 무엇인가요?
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb1zOw1%2FbtqL6HAW7jy%2FjpBA5pPkQFnfiZcPLakg00%2Fimg.png" width="50%">

### 해시 테이블
- 키에 해시 함수를 적용해서 배열의 인덱스로 변환하여 고유한 인덱스에 값을 저장하는 자료구조
- 해시값으로 바로 접근할 수 있어 검색, 삽입, 삭제 연산이 O(1)의 시간복잡도를 가짐
- 해시 테이블 크기를 미리 할당해야 하므로, 메모리 낭비가 발생할 수 있음
###### 해시란: 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수

### HashMap
- Key-Value 쌍으로 데이터를 저장하며, Key를 해시 함수에 넣어 해시값을 계산한 후 배열의 인덱스로 변환하여 값을 저장
- 해시테이블과 달리 동기화 처리를 하지 않고, Null 값을 허용하여 속도가 빠름
- 해시 값 충돌이 발생하면 해시테이블과 같이 해결. 체이닝 경우 검색에 O(n)의 시간복잡도를 가짐
- 평균적으로 삽입/조회/삭제는 O(1)의 시간복잡도를 가짐
###### 동기화 처리 : 멀티 스레드 환경에서 데이터의 일관성을 위해 데이터에 접근하는 것을 제한하는 것

### HashSet
- 중복을 허용하지 않는 데이터를 저장하며, 내부적으로 HashMap을 사용하여 데이터를 저장
- 중복된 데이터를 저장하지 않으므로 모든 값이 유일함
- 평균적으로 O(1)의 시간복잡도를 가짐
- 내부적으로 HashMap을 사용하기 때문에 HashMap과 동일한 성능을 가짐

# Hash Collision을 해결하는 방법에는 무엇이 있나요?
### Hash Collision이란?
- 서로 다른 키들이 동일한 해시 값을 갖는 것. 이를 해결하지 않으면 데이터가 덮어씌워질 수 있음.

### 체이닝(분리 연결법)
    
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbTF67c%2FbtqL7xx3OGw%2FDM8KEKU5x7dx6Nks4JR7K1%2Fimg.png" width="50%">

- 충돌이 발생하면 같은 해시값을 갖는 데이터들을 연결 리스트로 연결하는 방식
- 테이블 확장이 필요없고 구현이 간단.
- 하지만 연결 리스트의 길이가 길어지면 검색 시간이 O(n)으로 느려질 수 있음.

### 개방주소법

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FWR1fv%2FbtqL5APCcSa%2FBZN6wvxUXzJBEiOfOMLfR0%2Fimg.png" width="50%">

- 충돌이 발생하면 다른 해시값을 찾아 데이터를 저장하는 방식
- 효율적인 메모리 사용
- 종류
  - 선형 조사(Linear Probing): 다음 빈 버킷에 저장. 현재 index부터 고정폭만큼 이동하여 비어있는 버킷에 저장.
    - 군집화 문제(Clustering Problem)가 발생할 수 있음.
  - 이차 조사(Quadratic Probing): 제곱수만큼 떨어진 버킷에 저장. 충돌이 발생하면 1만큼 이동하고 계속 충돋이 발생하면 4, 9, 16, ...만큼 이동
    - 군집화 문제를 해결할 수 있지만 빈 버킷을 찾기 어려움
  - 이중 해싱(Double Hashing): 두 번째 해시 함수를 이용하여 다음 빈 버킷에 저장.
    - 선형 조사와 이차 조사의 단점을 보완했지만 구현이 복잡함.
###### 군집화 문제(Clustering Problem): 충돌이 발생하면 데이터들이 군집을 이루어 저장되는 현상

# HashMap과 HashSet의 차이점은 무엇인가요?
| 특성           | HashMap                                         | HashSet                                  |
|----------------|-------------------------------------------------|------------------------------------------|
| **저장 형태**    | Key-Value Pair (키와 값 쌍)                      | 단일 Value (값만 저장)                    |
| **키/값의 유일성** | 키는 유일, 값은 중복 가능                            | 모든 값이 유일                             |
| **Null 허용 여부** | 키와 값 모두 허용 (단, 키는 하나의 Null만 가능)       | 한 개의 Null 값만 허용                     |
| **내부 구조**    | HashTable 기반 | HashMap 기반 |
| **적용 예시**    | 데이터의 키-값 매핑 필요 시 (예: 학생 ID-성적 저장)      | 중복을 피한 고유 값 모음 필요 시 (예: 유일한 태그 집합) |

### HashMap과 HashTable의 차이점
| 특성           | HashMap                                         | HashTable                        |
|----------------|-------------------------------------------------|----------------------------------|
| **동기화**    | 비동기화 (Non-Synchronized)                      | 동기화 (Synchronized)               |
| **속도** | 빠름                            | 느림                               |
| **Null 허용 여부** | 키와 값 모두 허용 (단, 키는 하나의 Null만 가능)       | 키와 값 모두 허용 (단, 키와 값 모두 Null 불가능) | 
| **적용 예시**    | 데이터의 키-값 매핑 필요 시 (예: 학생 ID-성적 저장)      | HashMap과 동일                      |
