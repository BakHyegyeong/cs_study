### Q1. LinkedList와 ArrayList의 각각의 장단점
- LinkedList
    - 장점 : 삽입/삭제가 빠르다.
    - 단점 : N번째를 찾기위해 O(n)의 시간복잡도가 걸리므로, 탐색 시간이 오래 걸린다.(순차 접근)
- ArrayList
    - 장점 : 인덱스만 알면 O(1)로 탐색 시간이 빠르다.(임의 접근)
    - 단점 : 삽입/삭제 시간이 오래 걸린다.
        - 삽입할 때 배열 복사
        - 삭제할 때 뒤의 요소들을 이동

### Q2. LinkedList란?
- 데이터를 감싼 노드가 다음 노드에 대한 포인터를 가지고 있는 공간적인 효율성을 극대화시킨 자료 구조이다.
- index기반 접근시 ArrayList가 더 빠른 반면 LinkedList는 삽입, 삭제에서 강점이 있다.
- 데이터 크기가 가변적일 때 메모리 관리가 유연한 자료구조이다.

### Q3. 단일 연결 리스트와 이중 연결 리스트의 차이점
- 단일 연결 리스트는 각 노드가 다음 노드에만 포인터를 가지고 있어 단방향 탐색만 가능하다.
- 이중 연결 리스트는 전, 후 노드의 포인터를 가지고 있어 양방향으로 탐색이 가능하다.

#### Q4. Array와 LinkedList의 메모리 할당부분에서의 차이점
- 배열에서 메모리는 선언시 컴파일 타임에 할당된다. 
- LinkedList는 새로운 데이터가 추가되는 런타임에 메모리가 할당된다.

### Q5. LinkedList에서 데이터 순서를 거꾸로 만들려면 어떻게 해야 하나요?
- LinkedList의 데이터를 역순으로 만들기 위해서는 각 노드를 순회하면서 next 포인터를 반대로 연결해야 합니다. 
- 단일 LinkedList의 경우에는 추가 메모리를 사용해 역순으로 데이터를 임시 저장하거나 이중 LinkedList를 사용하여 양방향으로 순회하면서 순서를 바꿀 수 있습니다. 
- 노드 개수에 따라 O(n) 시간 복잡도를 가집니다.

### Q6. LinkedList의 삽입/삭제 성능이 언제 비효율적인가요?
- LinkedList에서 삽입과 삭제는 노드 자체에서 이루어질 때는 O(1) 시간 복잡도로 빠릅니다. 하지만 특정 위치에 삽입 또는 삭제가 필요할 경우에는 그 위치를 찾기 위한 탐색이 선행되므로 O(n)의 시간이 걸립니다. 
- 특히 중간 지점이나 특정 인덱스의 노드를 찾기 위해 순회가 필요하므로 데이터가 많아질수록 성능이 저하될 수 있습니다.

### Q7. LinkedList의 성능을 보완하기 위해 나온 자료구조는 무엇인가요?
- LinkedList의 느린 검색 성능을 보완하기 위해 Hash Table을 사용할 수 있습니다. Hash Table은 특정 키를 기반으로 데이터를 저장하여 빠르게 검색이 가능하기에 LinkedList보다 훨씬 빠르게 원하는 데이터에 접근할 수 있습니다.

### Q8. LinkedList 시간 복잡도 문제(3문제)
1. 단일 LinkedList에서 마지막 노드를 찾는 데 걸리는 시간 복잡도는? O(n)
2. 원형 이중 LinkedList에서 head 노드를 알 때 tail 노드를 찾는 시간 복잡도는? O(1)
3. 이중 연결리스트에서 tail 노드를 찾는 시간 복잡도는? O(n)
