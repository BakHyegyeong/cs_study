# 비관적 락과 낙관적 락

데이터베이스에서 동시성 제어를 위해 사용된다.

→ 여러 사용자가 동시에 데이터를 읽고 쓸 때 **데이터의 일관성을 지키기 위해 다양한 락 메커니즘을 사용한다.**

## 비관적 락

**데이터에 접근할 때마다 락**을 걸어 다른 트랜잭션이 접근하지 못하게 하는 방식

- 공유락 (Shared Lock) : 다른 트랜잭션에서 **읽는 작업만 가능**
- 베타락 (Exclusive Lock) : 다른 트랜잭션에서 **읽기, 쓰기 모두 불가능**
- Repeatable Read 또는 Serializable 정도의 격리성 수준을 제공한다.

### 사용 방법

트랜잭션이 시작될 때 **Shared Lock 또는 Exclusive Lock을 걸고 시작**한다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F5wxW6%2Fbtq9hyUsNAt%2FKtepF9HSKgm19t3G9RRoVK%2Fimg.png)

1. Transaction_1 에서 table의 Id 2번을 읽음 ( name = Karol )
2. Transaction_2 에서 table의 Id 2번을 읽음 ( name = Karol )
3. Transaction_2 에서 table의 Id 2번의 name을 Karol2로 변경 요청 ( name = Karol )
    
    **→ 하지만 Transaction 1에서 이미 shared Lock을 잡고 있기 때문에 Blocking**
    
4. Transaction_1 에서 트랜잭션 해제 (commit)
5. Blocking 되어있었던 Transaction_2의 update 요청 정상 처리

### 장단점

- 장점
    - 데이터의 일관성을 보장할 수 있다.
    - 충돌이 발생할 가능성이 적다.
    - 구현이 비교적 간단하다.

- 단점
    - 성능이 저하될 수 있다.
    - 다른 트랜잭션의 접근을 차단하기 때문에 병목 현상이 발생할 수 있다.
    - 락을 걸고 해제하는 과정에서 오버헤드가 발생할 수 있다.

## 낙관적 락

데이터에 접근할 때 락을 걸지 않고, **트랜잭션이 완료될 때 충돌이 발생했는지 확인**하는 방식

→ 대부분의 트랜잭션이 **충돌이 발생하지 않을 것이라 낙관적으로 가정**한다.

- 충돌이 발생했을 때 데이터베이스가 아니라 **애플리케이션 단에서 처리**한다.
    
    → 개발자가 **수동으로 롤백**을 수행해야 한다.
    
- version, hashcode, timestamp의 **별도의 컬럼을 이용해서 충돌을 예방**한다.

### 사용 방법

수정할 때 **수정했다고 명시**하여 다른 트랜잭션이 **동일한 조건으로 값을 수정할 수 없게 한다.**

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FINtDF%2Fbtq9hzFPQQU%2FIvsEoEH3yYXqL1irPPs4W1%2Fimg.png)

1. A가 table의 Id 2번을 읽음 ( name = Karol, version = 1 )
2. B가 table의 Id 2번을 읽음 ( name = Karol, version = 1 )
3. B가 table의 Id 2번, version 1인 row의 값 갱신 ( name = Karol2, version = 2 ) 성공
4. A가 table의 Id 2번, version 1인 row의 값 갱신 ( name = Karol1, version = 2 ) 실패
    
    **→ Id 2번은 이미 version이 2로 업데이트 되었기 때문에 A는 해당 row를 갱신하지 못함**
    

### 장단점

- 장점
    - 성능이 향상될 수 있다.
    - 다른 트랜잭션의 접근을 차단하지 않기 때문에 병목 현상이 발생하지 않는다.
    - 락을 걸고 해제하는 과정에서 오버헤드가 발생하지 않는다.

- 단점
    - 데이터의 일관성을 보장하기 어렵다.
    - 충돌이 발생할 가능성이 있다.
    - 구현이 비교적 복잡하다.

## 비관적 락과 낙관적 락의 비교

- 비관적 락 : 충돌이 많이 발생하고 데이터의 일관성이 더 중요한 애플리케이션
    
    → 금융, 재고 관리, 예약 시스템 등
    
- 낙관적 락 : 충돌이 적게 발생하고 성능이 더 중요한 애플리케이션
    
    → 소셜 네트워크, 블로그, 전자 상거래 시스템 등
    

| 구분 | 비관적 락 | 낙관적 락 |
| --- | --- | --- |
| **일관성** | 데이터의 일관성을 보장할 수 있다. | 데이터의 일관성을 보장하기 어렵다. |
| **충돌 가능성** | 충돌이 발생할 가능성이 적다. | 충돌이 발생할 가능성이 있다. |
| **구현 난이도** | 구현이 비교적 간단하다. | 구현이 비교적 복잡하다. |
| **성능** | 성능이 저하될 수 있다. | 성능이 향상될 수 있다. |
| **병목현상** | 다른 트랜잭션의 접근을 차단하기 때문에 병목 현상이 발생할 수 있다. | 다른 트랜잭션의 접근을 차단하지 않아 병목 현상이 발생하지 않는다. |
| **오버헤드** | 락을 걸고 해제하는 과정에서 오버헤드가 발생할 수 있다. | 락을 걸고 해제하는 과정에서 오버헤드가 발생하지 않는다. |

---

## 격리 수준

![](https://velog.velcdn.com/images/kim_dg/post/9727355f-f112-4c1e-958a-7300949e06a8/image.png)

- SERIALIZABLE : 트랜잭션을 **순차적으로** 진행시키는 것
→ **여러 트랜잭션이 같은 행에 접근할 수 없다.**
    
    → 교착 상태가 일어날 확률이 높고 가장 성능이 떨어진다.
    
- REPEATABLE_READ : 다른 트랜잭션이 수정할 수 없도록 막지만 새로운 행을 추가하는 것은 가능하게 하는 것 <br>
→ 트랜잭션 수행시 **수정은 막지만 삽입은 막지 않는 것**
- **READ_COMMITTED** : 가장 많이 사용되며 **커밋 완료된 데이터에 대해서만 조회를 허용하지만 트랜잭션간의 수정을 막지 않는 것** <br>
→ 트랜잭션안에서 조회시 데이터가 달라질 수 있다.
- READ_UNCOMMITTED : 가장 낮은 격리 수준으로 커밋이 되기 전에 다른 트랜잭션이 접근할 수 있다. <br>
→ 보통은 무결성을 위해 사용하지 않으나 거대한 양의 데이터를 집계할 때 사용된다.

## 격리 수준에 따른 현상

- 팬텀 리드 : 한 트랜잭션 내에서 동일한 쿼리를 사용했음에도 불구하고 조회 결과가 달라지는 것 <br>
→ **조건문을 통한 조회 결과가 달라지는 것**
- 반복 가능하지 않은 조회 : 한 트랜잭션 내에서 같은 행에 두 번 이상의 조회가 발생했을 때 각각의 결과가 달라지는 것 <br>
→ **한 행의 조회 결과가 달라지는 것**
- 더티 리드 : 커밋되지 않은 행의 변경된 데이터를 보는 것