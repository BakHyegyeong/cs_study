## **Q1. 인덱스**
- 데이터베이스의 검색 속도를 높이기 위한 자료구조
- 빨라지는 이유는 데이터를 풀 스캔을 하지 않고, 인덱스를 통해 검색하기 때문
- 인덱스는 추가적인 저장공간을 필요로 하며, 추가 작업을 하므로 데이터의 삽입, 수정, 삭제가 느려질 수 있음

---

## **Q2. 다중 컬럼 인덱스**
- 여러 컬럼을 조합하여 인덱스를 거는 것
- 주의할 점은 컬럼 순서가 중요하다
- 첫 번째 컬럼이 같은 경우에만 두 번째 컬럼으로 정렬이 이루어진다

---

## **Q3. 쿼리 힌트(Query Hint)는 무엇이고, 언제 사용하는 것이 적합한가요?**
- 옵티마이저가 생성한 실행 계획을 변경하거나, 옵티마이저가 선택한 실행 계획을 강제할 때 사용
- 옵티마이저가 생성한 실행 계획이 비효율적일 때 사용
- 조인 순서나 해당 인덱스를 강제하도록 하는 등의 목적으로 사용

---

## **Q4. 인덱스 구현 알고리즘의 종류**
- 해시 테이블
- 바이너리 트리
- B-Tree / B+tree
- Trie (prefix tree)

---

## **Q5. 각 연산의 인덱스 관리 방법**
- 재정렬과 함께 각각 아래의 연산이 수행된다
    - **INSERT**: 새로운 데이터에 대한 인덱스를 추가한다
    - **DELETE**: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행한다
    - **UPDATE**: 기존의 인덱스를 사용하지 않음 처리하고 갱신된 데이터에 대한 인덱스를 추가한다

---

## **Q6. 옵티마이저 실행 과정**
- 사용자로부터 전달받은 쿼리를 수행하는데 사용될 후보군인 실행 계획들을 찾는다
- 데이터 딕셔너리에 미리 수집한 통계 정보를 이용해서 각 실행 계획의 예상 비용을 산정한다
- 최저 비용(cost)을 나타내는 실행 계획을 선택한다

---

## **Q7. SQL문 처리 과정에서 실행 계획은 어떤 단계에 속하는지**
- SQL 최적화: SQL이 실행되는데 필요한 cost를 계산, 실행 계획 작성

---

## **Q8. 인덱스를 설정하는 기준은?**
- 규모가 큰 테이블이고 insert, update, delete가 자주 발생하지 않는 테이블
- join, where, order by에 자주 사용되는 컬럼
- 데이터의 중복도가 낮고, 검색 빈도 높은 컬럼에 인덱스를 설정해야 한다

---

## **Q9. 실행 계획(EXPLAIN)이란?**
- SQL문을 수행할 때 옵티마이저가 실행 비용을 계산해서 가장 최적의 실행 방식을 찾는 것을 의미한다
